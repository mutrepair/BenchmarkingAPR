{
          "0": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) && ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "1": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) | ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "2": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) || ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "3": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow & (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "4": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "5": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >>> (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "6": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow % (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "7": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow <= (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "8": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow > (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "9": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow < (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "10": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow - (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "11": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow | (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "12": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >= (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "13": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow >> zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "14": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow <= zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "15": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow >>> zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "16": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow >= zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "17": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) + ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "18": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "19": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow > zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "20": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) < ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "21": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) == ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "22": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 <= zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "23": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 >> zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "24": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 << zn) - 2));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "25": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 >>> zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "26": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 >= zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "27": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow < zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "28": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow & zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "29": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) * ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "30": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) != ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "31": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 - zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "32": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 > zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "33": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow == zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "34": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) - ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "35": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 << zn) - 0));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "36": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zvec)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "37": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = (bsBuffShadow >> (bsLiveShadow % zn));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "38": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 % zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "39": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 < zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "40": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 & zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "41": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % bsLiveShadow)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "42": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 == zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "43": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % bsBuffShadow)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "44": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "45": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (zvec % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "46": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((zvec >> (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "47": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (zn % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "48": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsBuffShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "49": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((zn >> (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "50": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nreturn;\n                    int zvec = (bsBuffShadow >> (bsLiveShadow % zn))\n                        & ((1 << zn) - 1);                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "51": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> (bsLiveShadow % zn)) & ((1 << zn) - 8));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "52": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nfinal int thech = inShadow.read();\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "53": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsLiveShadow >> (bsLiveShadow % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "54": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nint zvec = ((bsBuffShadow >> ( % zn)) & ((1 << zn) - 1));\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "55": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\nbreak;\n                    int zvec = (bsBuffShadow >> (bsLiveShadow % zn))\n                        & ((1 << zn) - 1);                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "56": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\ncontinue;\n                    int zvec = (bsBuffShadow >> (bsLiveShadow % zn))\n                        & ((1 << zn) - 1);                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }"
}