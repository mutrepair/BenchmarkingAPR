{
          "0": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 1));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "1": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 2));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "2": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nbreak;\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "3": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 0));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "4": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "5": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nreturn;\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "6": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "7": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 1) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "8": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 2) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "9": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | (c & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "10": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(1 | ((c >> 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "11": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(2 | ((c >> 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "12": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nillegalSurrogate(c);\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "13": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nclose();\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "14": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nflush();\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "15": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n_outPtr = outPtr;\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "16": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 12) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "17": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "18": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c & 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "19": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 0) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "20": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 0x80));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "21": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0 | ((c >> 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "22": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c - 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "23": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | -1));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "24": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c % 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "25": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c | 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "26": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "27": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\ncontinue;\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "28": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "29": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) & 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "30": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "31": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >>> 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "32": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nillegalSurrogate(c);\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "33": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | (c & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "34": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n_outPtr = outPtr;\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "35": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c * 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "36": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c / 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "37": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif(((c >> 6) | 63)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "38": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c << 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "39": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((c >> 12)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "40": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c <= 6) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "41": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) - 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "42": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((c < SURR1_FIRST)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "43": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 0xf0));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "44": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((c & 0x3f)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "45": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "46": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((off >= len)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "47": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((c > 0x10FFFF)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "48": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) % 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "49": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 12) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "50": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nif((c > SURR1_LAST)){\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n}\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "51": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\nc = convertSurrogate(cbuf[off++]);\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "52": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) * 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "53": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 6));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "54": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) <= 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "55": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) >> 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "56": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) >>> 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "57": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) / 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "58": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 0x80) | 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "59": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) << 63));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "60": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) | 63));                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "61": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)(0x80 | ((c >> 6) | 12));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "62": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)c;\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "63": "    public void write(char[] cbuf, int off, int len)\n        throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(cbuf[off]);\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = cbuf[off++];\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = cbuf[off++];\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = cbuf[off++];\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\noutBuf[outPtr++] = (byte)c[outPtr++];\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(cbuf[off++]);\n                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }"
}