{
          "0": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n    }",
          "1": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nskipRecord();\n        return false;    }",
          "2": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nwriteBlock();\n        return false;    }",
          "3": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nflushBlock();\n        return false;    }",
          "4": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nclose();\n        return false;    }",
          "5": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn true;    }",
          "6": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.println(((((\"null\" + numBytes) + \"null\") + blockSize) + \"null\"));\n        return false;    }",
          "7": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbytesNeeded -= numBytes;\n        return false;    }",
          "8": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.skipRecord();\n        return false;    }",
          "9": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.writeBlock();\n        return false;    }",
          "10": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.flushBlock();\n        return false;    }",
          "11": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.close();\n        return false;    }",
          "12": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\noffset += numBytes;\n        return false;    }",
          "13": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.fill(blockBuffer, offset, (offset + bytesNeeded), (byte)0);\n        return false;    }",
          "14": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ncurrBlkIdx++;\n        return false;    }",
          "15": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn false;        return false;    }",
          "16": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn false;    }",
          "17": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ncurrRecIdx = 0;\n        return false;    }",
          "18": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.println((\"null\" + currBlkIdx));\n        return false;    }",
          "19": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbreak;\n        return false;    }",
          "20": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.skipRecord();\n        return false;    }",
          "21": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.writeBlock();\n        return false;    }",
          "22": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.flushBlock();\n        return false;    }",
          "23": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nSystem.err.close();\n        return false;    }",
          "24": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ncontinue;\n    }",
          "25": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn true;        return false;    }",
          "26": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.skipRecord();\n        return false;    }",
          "27": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.writeBlock();\n        return false;    }",
          "28": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.flushBlock();\n        return false;    }",
          "29": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.close();\n        return false;    }",
          "30": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbreak;\n    }",
          "31": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn blockBuffer;    }",
          "32": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn null;    }",
          "33": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn;\n        return false;    }",
          "34": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.skipRecord();\n        return false;    }",
          "35": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.writeBlock();\n        return false;    }",
          "36": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.flushBlock();\n        return false;    }",
          "37": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n.close();\n        return false;    }",
          "38": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn bytesNeeded;    }",
          "39": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn \"null\";    }",
          "40": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbytesNeeded++;\n        return false;    }",
          "41": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ncontinue;\n        return false;    }",
          "42": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nif((offset == 0)){\n}\n        return false;    }",
          "43": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nif(debug){\n}\n        return false;    }",
          "44": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nsuper.readBlock();\n        return false;    }",
          "45": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn -true;    }",
          "46": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nnumBytes++;\n        return false;    }",
          "47": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = false;\n        return false;    }",
          "48": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nif((((\"null\" + numBytes) + \"null\") + blockSize)){\n}\n        return false;    }",
          "49": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nif((offset + bytesNeeded)){\n}\n        return false;    }",
          "50": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\noffset = false;\n        return false;    }",
          "51": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbytesNeeded = false;\n        return false;    }",
          "52": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nif(((\"null\" + numBytes) + \"null\")){\n}\n        return false;    }",
          "53": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn (offset + bytesNeeded);    }",
          "54": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = true;\n        return false;    }",
          "55": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\noffset = true;\n        return false;    }",
          "56": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nbytesNeeded = true;\n        return false;    }",
          "57": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nreturn;\n    }",
          "58": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\n        return false;    }",
          "59": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = null;\n        return false;    }",
          "60": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = bytesNeeded;\n        return false;    }",
          "61": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nArrays.println(false);\n        return false;    }",
          "62": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ndebug = false;\n        return false;    }",
          "63": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = offset;\n        return false;    }",
          "64": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\ndebug = true;\n        return false;    }",
          "65": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer = blockBuffer;\n        return false;    }",
          "66": "    private boolean readBlock() throws IOException {\n        if (debug) {\n            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n        }\n\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset,\n                                               bytesNeeded);\n\n            //\n            // NOTE\n            // We have fit EOF, and the block is not full!\n            //\n            // This is a broken archive. It does not follow the standard\n            // blocking algorithm. However, because we are generous, and\n            // it requires little effort, we will simply ignore the error\n            // and continue as if the entire block were read. This does\n            // not appear to break anything upstream. We used to return\n            // false in this case.\n            //\n            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n            //\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    // Ensure that we do not read gigabytes of zeros\n                    // for a corrupt tar file.\n                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n                    return false;\n                }\n                // However, just leaving the unread portion of the buffer dirty does\n                // cause problems in some cases.  This problem is described in\n                // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                //\n                // The solution is to fill the unused portion of the buffer with zeros.\n\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                if (debug) {\n                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n                                       + numBytes + \" of \" + blockSize\n                                       + \" bytes read.\");\n                }\n            }\n        }\n\n        currBlkIdx++;\n\nblockBuffer += true;\n        return false;    }"
}