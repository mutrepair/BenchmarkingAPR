{
          "0": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "1": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (true)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "2": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(sort);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "3": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(alpha);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "4": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:alpha.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "5": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:_config.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "6": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "7": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = ;\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "8": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (\"null\")?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "9": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.shouldSortPropertiesAlphabetically(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "10": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nfinal String [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "11": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nintr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "12": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.getName(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "13": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "14": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.booleanValue(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "15": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef._classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "16": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(getClassDef()._classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "17": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr._sortProperties(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "18": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?intr.findSerializationPropertyOrder(_classDef):intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "19": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "20": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.get(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "21": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.toString(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "22": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:_classDef;\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "23": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])_classDef;\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "24": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?_classDef:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "25": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = new String [](_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "26": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (intr.findSerializationPropertyOrder(_classDef))?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "27": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (-true)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "28": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef.alpha);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "29": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(getClassDef().alpha);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "30": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef.sort);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "31": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(getClassDef().sort);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "32": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nreturn;\n        String[] propertyOrder = (false) ? null : intr.findSerializationPropertyOrder(_classDef);        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "33": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (-\"null\")?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "34": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (-1)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "35": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(intr.findSerializationPropertyOrder(_classDef));\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "36": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (1)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "37": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = this._classDef.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "38": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?true:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "39": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(_classDef, _classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "40": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "41": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (0)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "42": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = ((_classDef != null))?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "43": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = ((_classDef == null))?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "44": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = intr.findSerializationPropertyOrder(_classDef, _classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "45": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?intr.findSerializationPropertyOrder(_classDef, _classDef):intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "46": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (null)?null:intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "47": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(false);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "48": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "49": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:(_classDef + null);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "50": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?null:intr.findSerializationPropertyOrder(_classDef, _classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "51": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(true);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "52": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (false)?intr.findSerializationPropertyOrder(intr.findSerializationPropertyOrder(_classDef)):intr.findSerializationPropertyOrder(_classDef);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "53": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(_classDef, false);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "54": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nString [] propertyOrder = (String [])intr.findSerializationPropertyOrder(_classDef, true);\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "55": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nsort = alpha.booleanValue();\n        String[] propertyOrder = (false) ? null : intr.findSerializationPropertyOrder(_classDef);        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "56": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nsort = _config.shouldSortPropertiesAlphabetically();\n        String[] propertyOrder = (false) ? null : intr.findSerializationPropertyOrder(_classDef);        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "57": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nsort = _config.shouldSortPropertiesAlphabetically();\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "58": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nsort = alpha.booleanValue();\n        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "59": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\nbreak;\n        String[] propertyOrder = (false) ? null : intr.findSerializationPropertyOrder(_classDef);        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        ",
          "60": "    protected void _sortProperties()\n    {\n        // Then how about explicit ordering?\n        AnnotationIntrospector intr = _annotationIntrospector;\n        boolean sort;\n        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n        \n        if (alpha == null) {\n            sort = _config.shouldSortPropertiesAlphabetically();\n        } else {\n            sort = alpha.booleanValue();\n        }\ncontinue;\n        String[] propertyOrder = (false) ? null : intr.findSerializationPropertyOrder(_classDef);        \n        // no sorting? no need to shuffle, then\n        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n            return;\n        }\n        int size = _properties.size();\n        Map<String, POJOPropertyBuilder> all;\n        // Need to (re)sort alphabetically?\n        if (sort) {\n            all = new TreeMap<String,POJOPropertyBuilder>();\n        } else {\n            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        }\n\n        for (POJOPropertyBuilder prop : _properties.values()) {\n            all.put(prop.getName(), prop);\n        }\n        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n        // Ok: primarily by explicit order\n        if (propertyOrder != null) {\n            for (String name : propertyOrder) {\n                POJOPropertyBuilder w = all.get(name);\n                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n                    for (POJOPropertyBuilder prop : _properties.values()) {\n                        if (name.equals(prop.getInternalName())) {\n                            w = prop;\n                            // plus re-map to external name, to avoid dups:\n                            name = prop.getName();\n                            break;\n                        }\n                    }\n                }\n                if (w != null) {\n                    ordered.put(name, w);\n                }\n            }\n        }\n        // And secondly by sorting Creator properties before other unordered properties\n        if (_creatorProperties != null) {\n            for (POJOPropertyBuilder prop : _creatorProperties) {\n                ordered.put(prop.getName(), prop);\n            }\n        }\n        // And finally whatever is left (trying to put again will not change ordering)\n        ordered.putAll(all);\n        \n        _properties.clear();\n        _properties.putAll(ordered);\n    }        "
}