{
          "0": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn 0;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "1": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new int[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "2": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[2];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "3": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[(lastData - numberQuadruple)];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "4": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new long[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "5": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "6": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn 1;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "7": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\ndecodedData = new byte[(lastData - numberQuadruple)];\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "8": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "9": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn 2;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "10": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn decodedData;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "11": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn lastData;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "12": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[-2];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "13": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn dataIndex;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "14": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nbreak;\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "15": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn -1;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "16": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\ncontinue;\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "17": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn numberQuadruple;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "18": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn false;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "19": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn;\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "20": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn ;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "21": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[0];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "22": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new int[(lastData - numberQuadruple)];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "23": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((--lastData == 0)){\n}\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "24": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[false];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "25": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn -2;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "26": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "27": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn true;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "28": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn PAD;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "29": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn null;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "30": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[true];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "31": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((base64Data[(lastData - 1)] == PAD)){\n}\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "32": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\ncontinue;\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "33": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn this;                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "34": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[null];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "35": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[(lastData - numberQuadruple)]};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "36": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[-1];                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "37": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new int[(lastData - numberQuadruple)]};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "38": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[-1]};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "39": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nbreak;\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "40": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new boolean[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "41": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn;\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "42": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "43": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((lastData != null)){\n}\n                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "44": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\ndecodedData = new byte[(lastData - numberQuadruple)];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "45": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[(lastData - numberQuadruple)]{decodedData};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "46": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new byte[(lastData - numberQuadruple)]{numberQuadruple};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "47": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new int[(lastData - numberQuadruple)]{decodedData};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "48": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nreturn new int[(lastData - numberQuadruple)]{numberQuadruple};                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "49": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((lastData != null)){\ndecodedData = 0;\n}                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "50": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((lastData != null)){\ndecodedData = lastData;\n}                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "51": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((lastData != null)){\ndecodedData = decodedData;\n}                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "52": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n            while (base64Data[lastData - 1] == PAD) {\n                if (--lastData == 0) {\nif((lastData != null)){\nlastData = new boolean[0];\n}                    return new byte[-1];                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }"
}