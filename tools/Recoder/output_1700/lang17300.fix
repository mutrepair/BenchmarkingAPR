{
          "0": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.add(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "1": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "2": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.multiplyBy(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "3": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.divideBy(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "4": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (false)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "5": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.subtract(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "6": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.multiplyBy(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "7": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.divideBy(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "8": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "9": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):BigInteger.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "10": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.add(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "11": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (1)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "12": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "13": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.valueOf(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "14": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (0)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "15": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nBigInteger t = (true)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "16": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.getName(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "17": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (null)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "18": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.add(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "19": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nuvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "20": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = ;\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "21": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "22": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.addSub(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "23": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.toString(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "24": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.multiply(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "25": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.get(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "26": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (\"null\")?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "27": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ZERO);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "28": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "29": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_HALF);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "30": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_THIRD);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "31": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_THIRDS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "32": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_QUARTER);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "33": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "34": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "35": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_FIFTH);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "36": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "37": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "38": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(FOUR_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "39": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "40": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ZERO);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "41": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ONE);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "42": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ONE_HALF);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "43": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ONE_THIRD);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "44": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(TWO_THIRDS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "45": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ONE_QUARTER);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "46": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(TWO_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "47": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(THREE_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "48": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(ONE_FIFTH);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "49": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(TWO_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "50": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(THREE_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "51": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = uvp.subtract(FOUR_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "52": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(upv))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "53": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.subtract();\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "54": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (2)?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "55": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ZERO):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "56": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ONE):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "57": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ONE_HALF):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "58": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ONE_THIRD):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "59": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(TWO_THIRDS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "60": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ONE_QUARTER):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "61": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(TWO_QUARTERS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "62": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(THREE_QUARTERS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "63": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(ONE_FIFTH):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "64": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(TWO_FIFTHS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "65": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(THREE_FIFTHS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "66": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.subtract(FOUR_FIFTHS):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "67": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (true)?uvp.add(upv):uvp.add(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "68": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.add(upv):uvp.subtract(tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "69": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ZERO);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "70": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ONE);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "71": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ONE_HALF);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "72": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ONE_THIRD);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "73": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(TWO_THIRDS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "74": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ONE_QUARTER);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "75": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(TWO_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "76": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(THREE_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "77": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(ONE_FIFTH);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "78": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(TWO_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "79": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(THREE_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "80": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = subtract(FOUR_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "81": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ZERO);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "82": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ONE);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "83": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ONE_HALF);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "84": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ONE_THIRD);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "85": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(TWO_THIRDS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "86": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ONE_QUARTER);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "87": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(TWO_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "88": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(THREE_QUARTERS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "89": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(ONE_FIFTH);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "90": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(TWO_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "91": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(THREE_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "92": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = this.subtract(FOUR_FIFTHS);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "93": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.valueOf(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "94": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger t = (true)?uvp.addSub(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "95": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ZERO))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "96": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ONE))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "97": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ONE_HALF))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "98": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ONE_THIRD))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "99": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(TWO_THIRDS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "100": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ONE_QUARTER))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "101": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(TWO_QUARTERS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "102": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(THREE_QUARTERS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "103": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(ONE_FIFTH))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "104": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(TWO_FIFTHS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "105": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(THREE_FIFTHS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "106": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (uvp.subtract(FOUR_FIFTHS))?uvp.add(upv):uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "107": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "108": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(d1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "109": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ZERO));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "110": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "111": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_HALF));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "112": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_THIRD));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "113": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_THIRDS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "114": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_QUARTER));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "115": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_QUARTERS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "116": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(THREE_QUARTERS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "117": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_FIFTH));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "118": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_FIFTHS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "119": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(THREE_FIFTHS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "120": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(FOUR_FIFTHS));\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "121": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ZERO, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "122": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "123": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_HALF, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "124": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_THIRD, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "125": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_THIRDS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "126": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_QUARTER, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "127": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_QUARTERS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "128": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_QUARTERS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "129": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_FIFTH, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "130": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_FIFTHS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "131": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_FIFTHS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "132": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(FOUR_FIFTHS, false);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "133": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nreturn;\n        final BigInteger t = true ? uvp.add(upv) : uvp.subtract(upv);        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "134": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ZERO, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "135": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "136": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_HALF, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "137": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_THIRD, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "138": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_THIRDS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "139": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_QUARTER, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "140": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_QUARTERS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "141": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_QUARTERS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "142": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(ONE_FIFTH, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "143": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(TWO_FIFTHS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "144": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(THREE_FIFTHS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "145": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(FOUR_FIFTHS, true);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "146": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ZERO), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "147": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "148": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_HALF), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "149": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_THIRD), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "150": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_THIRDS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "151": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_QUARTER), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "152": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_QUARTERS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "153": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(THREE_QUARTERS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "154": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(ONE_FIFTH), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "155": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(TWO_FIFTHS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "156": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(THREE_FIFTHS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }",
          "157": "    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            final int uvp = mulAndCheck(numerator, fraction.denominator);\n            final int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        final BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\nfinal BigInteger  = (BigInteger)uvp.subtract(uvp.subtract(FOUR_FIFTHS), tmodd1);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }"
}