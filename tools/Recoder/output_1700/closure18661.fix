{
          "0": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "1": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getName(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "2": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (result == -1);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "3": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o2.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "4": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.getName(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "5": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o1.getValue(), o2.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "6": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker >= null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "7": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (tieBreaker != null);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "8": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result >= -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "9": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(result.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "10": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == 0) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "11": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (result != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "12": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.getValue(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "13": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker == null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "14": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker <= null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "15": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn tieBreaker.compare(o1.getValue(), o2.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "16": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result <= -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "17": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.getWeight(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "18": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker > null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "19": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):((result == -1) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "20": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result > -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "21": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result != -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "22": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (o2 != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "23": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare();        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "24": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "25": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(graph.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "26": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker:result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "27": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn ((result == -1) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "28": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker - null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "29": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.toString(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "30": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == 1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "31": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result - -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "32": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn ((result == -1))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "33": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.toString(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "34": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (int)(((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "35": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(result);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "36": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "37": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.compare(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "38": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?o1.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "39": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (o1 != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "40": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == 2) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "41": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o1);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "42": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getWeight(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "43": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(result):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "44": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(tieBreaker):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "45": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker < null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "46": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && ( != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "47": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result < -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "48": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker.compare(o1.getValue(), o2.getValue()));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "49": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o1.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "50": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(tieBreaker.compare(o1.getValue(), o2.getValue())):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "51": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "52": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker >> null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "53": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result >> -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "54": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && ( != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "55": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "56": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o2);        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "57": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "58": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker + null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "59": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result + -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "60": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?Math.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "61": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.get(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "62": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker >>> null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "63": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result >>> -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "64": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker, o1.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "65": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(tieBreaker, o1.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "66": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.lastIndexOf()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "67": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?LOG.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "68": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o1.getValue(), o1.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "69": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker, o2.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "70": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(tieBreaker, o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "71": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?graph.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "72": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(o2.getValue(), o1.getValue());        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "73": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(tieBreaker.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "74": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?result.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "75": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker.compare(tieBreaker));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "76": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn;\n          return result == -1 && tieBreaker != null ?\n              tieBreaker.compare(o1.getValue(), o2.getValue()) : result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "77": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):tieBreaker.compare(tieBreaker.compare(result));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "78": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):(((tieBreaker == null) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "79": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):(((tieBreaker == -1) && (tieBreaker != null)))?tieBreaker.compare(o1.getValue(), o2.getValue()):result;        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "80": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn ((((tieBreaker == null) && (tieBreaker != null)) && (tieBreaker != null)) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "81": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn ((((tieBreaker == -1) && (tieBreaker != null)) && (tieBreaker != null)) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "82": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker.compare(o2) == null)) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
          "83": "    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\nreturn (((result == -1) && (tieBreaker.compare(tieBreaker) == null)) && (tieBreaker != null));        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }"
}