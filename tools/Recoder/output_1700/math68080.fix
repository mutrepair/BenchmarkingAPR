{
          "0": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "1": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "2": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (((v1[i] + (dot2 * v2[i])) + (dot3 * v3[i])) + (dot4 * v4[i]));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "3": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "4": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (v2[i] + (theta * (v3[i] + (eta * v4[i]))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "5": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "6": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "7": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "8": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "9": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (v2[i] + (theta * (v3[i] + (eta * v4[i]))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "10": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "11": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (theta * (v3[i] + (eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "12": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (((v1[i] + (dot2 * v2[i])) + (dot3 * v3[i])) + (dot4 * v4[i]));\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "13": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (v3[i] + (eta * v4[i]));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "14": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (theta * (v3[i] + (eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "15": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (v3[i] + (eta * v4[i]));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "16": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((i < interpolatedState.length)){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "17": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = ((previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))) + i);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "18": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nfor(int i = 0;(i < interpolatedState.length);++i) {            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "19": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = ((previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))) + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "20": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nbreak;\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "21": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = (eta * v4[i]);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "22": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] += (previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "23": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] += (previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "24": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = ((previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))) + 1);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "25": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "26": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = ((previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))) + i);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "27": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (eta * v4[i]);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "28": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedDerivatives[i] = ((previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))) + (theta <= 0.5));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "29": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (theta * h);\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "30": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "31": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((v2[i] + (theta * (v3[i] + (eta * v4[i]))))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "32": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "33": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((theta * (v3[i] + (eta * v4[i])))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "34": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((v3[i] + (eta * v4[i]))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "35": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif(((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i])))))))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "36": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (i[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "37": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (A70[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "38": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (A72[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "39": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (A73[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "40": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (A74[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "41": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (A75[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "42": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D0[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "43": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "44": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D3[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "45": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D4[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "46": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D5[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "47": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (D6[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "48": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v1[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "49": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v3[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "50": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v4[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "51": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nreturn;\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "52": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (i[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "53": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif((theta <= 0.5)){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "54": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ni[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "55": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (eta * (interpolatedState[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "56": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (i[i] * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "57": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\nif(((v1[i] + (dot2 * v2[i])) + (dot3 * v3[i]))){\ncontinue;\n}\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "58": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (i[i] + ((theta * h) * (v1[i] / (eta * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "59": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = (previousState[i] + ((theta * h) * (v1[i] / (i * (v2[i] + (theta * (v3[i] + (eta * v4[i]))))))));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }",
          "60": "  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v1 == null) {\n        v1 = new double[interpolatedState.length];\n        v2 = new double[interpolatedState.length];\n        v3 = new double[interpolatedState.length];\n        v4 = new double[interpolatedState.length];\n      }\n\n      // no step finalization is needed for this interpolator\n\n      // we need to compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot0 = yDotK[0][i];\n          final double yDot2 = yDotK[2][i];\n          final double yDot3 = yDotK[3][i];\n          final double yDot4 = yDotK[4][i];\n          final double yDot5 = yDotK[5][i];\n          final double yDot6 = yDotK[6][i];\n          v1[i] = A70 * yDot0 + A72 * yDot2 + A73 * yDot3 + A74 * yDot4 + A75 * yDot5;\n          v2[i] = yDot0 - v1[i];\n          v3[i] = v1[i] - v2[i] - yDot6;\n          v4[i] = D0 * yDot0 + D2 * yDot2 + D3 * yDot3 + D4 * yDot4 + D5 * yDot5 + D6 * yDot6;\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    // interpolate\n    final double eta = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double dot2 = 1 - twoTheta;\n    final double dot3 = theta * (2 - 3 * theta);\n    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n    if ((previousState != null) && (theta <= 0.5)) {\n        for (int i = 0; i < interpolatedState.length; ++i) {\ncontinue;\n            interpolatedState[i] =\n                    previousState[i] + theta * h * (v1[i] / (eta * (v2[i] + theta * (v3[i] + eta * v4[i]))));            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    } else {\n        for (int i = 0; i < interpolatedState.length; ++i) {\n            interpolatedState[i] =\n                    currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n            interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n        }\n    }\n\n  }"
}