{
          "0": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i - (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "1": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i + (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "2": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 0)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "3": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i / (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "4": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = (i % (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "5": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 1)) + 0)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "6": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i <= (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "7": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "8": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i & (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "9": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i * (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "10": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i | (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "11": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nquadrant[i] = 0;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "12": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "13": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i < (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "14": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i >= (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "15": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = (last + 1);\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "16": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 1)) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "17": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = seqToUnseq[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "18": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = unseqToSeq[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "19": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selector[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "20": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selectorMtf[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "21": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nquadrant[i] = 0;\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "22": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((i % (last + 1)) + -1);\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "23": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((last + i) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "24": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nseqToUnseq[((i % (last + 1)) + -1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "25": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nunseqToSeq[((i % (last + 1)) + -1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "26": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselector[((i % (last + 1)) + -1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "27": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselectorMtf[((i % (last + 1)) + -1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "28": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((i % (last + 1)) + -1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "29": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = seqToUnseq[((last + i) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "30": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = unseqToSeq[((last + i) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "31": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selector[((last + i) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "32": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selectorMtf[((last + i) + 2)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "33": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + -1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "34": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nif((i % (last + 1))){\ncontinue;\n}\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "35": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = seqToUnseq;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "36": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = unseqToSeq;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "37": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selector;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "38": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = selectorMtf;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "39": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block;\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "40": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nif((i < NUM_OVERSHOOT_BYTES)){\ncontinue;\n}\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "41": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = (last + i);\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "42": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((last + i) + 2);\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "43": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 0)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "44": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nbreak;\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "45": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nseqToUnseq[((last + i) + 2)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "46": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nunseqToSeq[((last + i) + 2)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "47": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselector[((last + i) + 2)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "48": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselectorMtf[((last + i) + 2)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "49": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((block[((i % (last + 1)) + -1)] % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "50": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nif((last + 1)){\ncontinue;\n}\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "51": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nif(((i % (last + 1)) + -1)){\ncontinue;\n}\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "52": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "53": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((block[((last + i) + 2)] % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "54": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 1)) + 1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "55": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nfor(i = 0(i < NUM_OVERSHOOT_BYTES);i++) {            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "56": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((i % (last + 1)) + (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "57": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = (i + (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "58": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nif((last + i)){\ncontinue;\n}\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "59": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nseqToUnseq = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "60": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nunseqToSeq = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "61": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselector = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "62": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nselectorMtf = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "63": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "64": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 1)] = block[((i % (last + 1)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "65": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nreturn;\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "66": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = block[((i % (last + 2)) + -1)];\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "67": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\ncontinue;\n            block[last + i + 2] = block[(i % (last + 1)) + -1];        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "68": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((i + block[((i % (last + 1)) + -1)]) + (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "69": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((block[((i % (last + 1)) + -1)] + block) + (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }",
          "70": "    private void mainSort() {\n        int i, j, ss, sb;\n        int[] runningOrder = new int[256];\n        int[] copy = new int[256];\n        boolean[] bigDone = new boolean[256];\n        int c1, c2;\n        int numQSorted;\n\n        /*\n          In the various block-sized structures, live data runs\n          from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n          set up the overshoot area for block.\n        */\n\n        //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n\n        for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\nblock[((last + i) + 2)] = ((((block + block) + block) + (last + 1)) + (last + 1));\n        }\n        for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) {\n            quadrant[i] = 0;\n        }\n\n        block[0] = block[last + 1];\n\n        if (last < 4000) {\n            /*\n              Use simpleSort(), since the full sorting mechanism\n              has quite a large constant overhead.\n            */\n            for (i = 0; i <= last; i++) {\n                zptr[i] = i;\n            }\n            firstAttempt = false;\n            workDone = workLimit = 0;\n            simpleSort(0, last, 0);\n        } else {\n            numQSorted = 0;\n            for (i = 0; i <= 255; i++) {\n                bigDone[i] = false;\n            }\n\n            for (i = 0; i <= 65536; i++) {\n                ftab[i] = 0;\n            }\n\n            c1 = block[0];\n            for (i = 0; i <= last; i++) {\n                c2 = block[i + 1];\n                ftab[(c1 << 8) + c2]++;\n                c1 = c2;\n            }\n\n            for (i = 1; i <= 65536; i++) {\n                ftab[i] += ftab[i - 1];\n            }\n\n            c1 = block[1];\n            for (i = 0; i < last; i++) {\n                c2 = block[i + 2];\n                j = (c1 << 8) + c2;\n                c1 = c2;\n                ftab[j]--;\n                zptr[ftab[j]] = i;\n            }\n\n            j = ((block[last + 1]) << 8) + (block[1]);\n            ftab[j]--;\n            zptr[ftab[j]] = last;\n\n            /*\n              Now ftab contains the first loc of every small bucket.\n              Calculate the running order, from smallest to largest\n              big bucket.\n            */\n\n            for (i = 0; i <= 255; i++) {\n                runningOrder[i] = i;\n            }\n\n            {\n                int vv;\n                int h = 1;\n                do {\n                    h = 3 * h + 1;\n                }\n                while (h <= 256);\n                do {\n                    h = h / 3;\n                    for (i = h; i <= 255; i++) {\n                        vv = runningOrder[i];\n                        j = i;\n                        while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                - ftab[(runningOrder[j - h]) << 8])\n                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                            runningOrder[j] = runningOrder[j - h];\n                            j = j - h;\n                            if (j <= (h - 1)) {\n                                break;\n                            }\n                        }\n                        runningOrder[j] = vv;\n                    }\n                } while (h != 1);\n            }\n\n            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n                stack[count] = new StackElem();\n            }\n\n            /*\n              The main sorting loop.\n            */\n            for (i = 0; i <= 255; i++) {\n\n                /*\n                  Process big buckets, starting with the least full.\n                */\n                ss = runningOrder[i];\n\n                /*\n                  Complete the big bucket [ss] by quicksorting\n                  any unsorted small buckets [ss, j].  Hopefully\n                  previous pointer-scanning phases have already\n                  completed many of the small buckets [ss, j], so\n                  we don't have to sort them at all.\n                */\n                for (j = 0; j <= 255; j++) {\n                    sb = (ss << 8) + j;\n                    if (!((ftab[sb] & SETMASK) == SETMASK)) {\n                        int lo = ftab[sb] & CLEARMASK;\n                        int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                        if (hi > lo) {\n                            qSort3(lo, hi, 2, stack);\n                            numQSorted += (hi - lo + 1);\n                            if (workDone > workLimit && firstAttempt) {\n                                return;\n                            }\n                        }\n                        ftab[sb] |= SETMASK;\n                    }\n                }\n\n                /*\n                  The ss big bucket is now done.  Record this fact,\n                  and update the quadrant descriptors.  Remember to\n                  update quadrants in the overshoot area too, if\n                  necessary.  The \"if (i < 255)\" test merely skips\n                  this updating for the last bucket processed, since\n                  updating for the last bucket is pointless.\n                */\n                bigDone[ss] = true;\n\n                if (i < 255) {\n                    int bbStart  = ftab[ss << 8] & CLEARMASK;\n                    int bbSize   = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                    int shifts   = 0;\n\n                    while ((bbSize >> shifts) > 65534) {\n                        shifts++;\n                    }\n\n                    for (j = 0; j < bbSize; j++) {\n                        int a2update = zptr[bbStart + j];\n                        int qVal = (j >> shifts);\n                        quadrant[a2update] = qVal;\n                        if (a2update < NUM_OVERSHOOT_BYTES) {\n                            quadrant[a2update + last + 1] = qVal;\n                        }\n                    }\n\n                    if (!(((bbSize - 1) >> shifts) <= 65535)) {\n                        panic();\n                    }\n                }\n\n                /*\n                  Now scan this big bucket so as to synthesise the\n                  sorted order for small buckets [t, ss] for all t != ss.\n                */\n                for (j = 0; j <= 255; j++) {\n                    copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n                }\n\n                for (j = ftab[ss << 8] & CLEARMASK;\n                     j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {\n                    c1 = block[zptr[j]];\n                    if (!bigDone[c1]) {\n                        zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;\n                        copy[c1]++;\n                    }\n                }\n\n                for (j = 0; j <= 255; j++) {\n                    ftab[(j << 8) + ss] |= SETMASK;\n                }\n            }\n        }\n    }"
}