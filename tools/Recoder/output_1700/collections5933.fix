{
          "0": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize > sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "1": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize <= sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "2": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize >= sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "3": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize - sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "4": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize == sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "5": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize < sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "6": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize + sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "7": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize & sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "8": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize >> sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "9": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.size = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "10": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.height = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "11": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "12": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.nextIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "13": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.currentIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "14": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.expectedModCount = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "15": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "16": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheight = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "17": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nrelativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "18": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "19": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ncurrentIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "20": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nexpectedModCount = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "21": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "22": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % sAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "23": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % currentSize);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "24": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "25": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheight.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "26": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nrelativePosition.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "27": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "28": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ncurrentIndex.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "29": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nexpectedModCount.relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "30": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize().relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "31": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheightRightMinusLeft().relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "32": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex().relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "33": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\npreviousIndex().relativePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "34": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.size = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "35": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.height = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "36": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.nextIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "37": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.currentIndex = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "38": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.expectedModCount = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "39": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % relativePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "40": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % otherTreeMin);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "41": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % s);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "42": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = sParentAbsolutePosition;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "43": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sAbsolutePosition - currentSize);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "44": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sAbsolutePosition % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "45": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "46": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.relativePosition = (sAbsolutePosition - currentSize);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "47": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "48": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheight.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "49": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nrelativePosition.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "50": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "51": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ncurrentIndex.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "52": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nexpectedModCount.sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "53": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize().sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "54": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheightRightMinusLeft().sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "55": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex().sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "56": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\npreviousIndex().sParentAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "57": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ncurrentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "58": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsAbsolutePosition = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "59": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (otherTreeMin % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "60": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (currentSize % s.relativePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "61": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (s % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "62": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "63": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheight.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "64": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nrelativePosition.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "65": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "66": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ncurrentIndex.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "67": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nexpectedModCount.currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "68": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nsize().currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "69": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nheightRightMinusLeft().currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "70": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nnextIndex().currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "71": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\npreviousIndex().currentSize = (currentSize % sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "72": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sParentAbsolutePosition + sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "73": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns.max().setRight(null, otherTreeMin);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "74": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sParentAbsolutePosition & sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "75": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sParentAbsolutePosition | sParentAbsolutePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "76": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\ns = otherTreeMin;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "77": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\nreturn;\n            otherTreeMin.relativePosition = currentSize % sParentAbsolutePosition;\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }",
          "78": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<AVLNode<E>>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\notherTreeMin.relativePosition = (sParentAbsolutePosition + otherTreeMin.relativePosition);\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }"
}