{
          "0": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "1": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "2": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nreturn;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "3": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "4": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "5": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "6": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nt = t.getCause();\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "7": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(bean){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "8": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "9": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(t){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "10": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(isCachable()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "11": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(hasViews()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "12": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((t instanceof InvocationTargetException)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "13": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((t.getCause() != null)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "14": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!isCachable()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "15": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!hasViews()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "16": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "17": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nbreak;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "18": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((ctxt == null)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "19": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(t.getCause()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "20": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(-wrap){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "21": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && t.getCause())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "22": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "23": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "24": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(fieldName){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "25": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && t.getCause())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "26": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap.getCause()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "27": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && !wrap)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "28": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS))){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "29": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap.wrap()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "30": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((t instanceof IOException)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "31": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap.isEmpty()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "32": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && !fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "33": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(isCachable(t, bean, fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "34": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(hasViews(t, bean, fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "35": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((t instanceof InvocationTargetException)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "36": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && isCachable())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "37": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && hasViews())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "38": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(isCachable(DeserializationFeature.WRAP_EXCEPTIONS)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "39": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(hasViews(DeserializationFeature.WRAP_EXCEPTIONS)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "40": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap++){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "41": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap.wrap()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "42": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!t){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "43": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && isCachable())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "44": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && hasViews())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "45": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS))){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "46": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && !fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "47": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap.getCause()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "48": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && (t instanceof IOException))){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "49": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!getCause()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "50": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((t.getCause() != null)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "51": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((t instanceof RuntimeException)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "52": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap.isEmpty()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "53": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap || !wrap)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "54": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nt = null;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "55": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(wrap.isEnabled()){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "56": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((t instanceof RuntimeException)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "57": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(isCachable(wrap)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "58": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(hasViews(wrap)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "59": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!isCachable(DeserializationFeature.WRAP_EXCEPTIONS)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "60": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!hasViews(DeserializationFeature.WRAP_EXCEPTIONS)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "61": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "62": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && !bean)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "63": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\ncontinue;\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "64": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && !isCachable())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "65": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && !hasViews())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "66": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif(!wrap){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "67": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((ctxt == null)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "68": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && !wrap)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "69": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap || t.getCause())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "70": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && !bean)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "71": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap || t.getCause())){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "72": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!isCachable(t, bean, fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "73": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!hasViews(t, bean, fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "74": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!bean){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "75": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nif((t instanceof Error)){\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n}\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "76": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap || !fieldName)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "77": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "78": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(DeserializationFeature.wrap){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "79": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "80": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((t instanceof Error)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "81": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(!wrap){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "82": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nbreak;\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "83": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(ctxt){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "84": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((t instanceof IOException)){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "85": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((wrap && (wrap != null))){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "86": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif((!wrap && (fieldName != null))){\n                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "87": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {\nif(){                throw (IOException) t;\n            }\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }",
          "88": "    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n            DeserializationContext ctxt)\n        throws IOException\n    {\n        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n         *   StackOverflow: usually due to infinite loop. But that\n         *   usually gets hidden within an InvocationTargetException...\n         */\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n        if (t instanceof IOException) {            if (!wrap) {                throw (IOException) t;\n            }\n\nboolean wrap = ((ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS));\n        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            }\n        }\n        // [JACKSON-55] Need to add reference information\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }"
}