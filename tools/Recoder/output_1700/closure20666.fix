{
          "0": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (false)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "1": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?isPrototypeGet:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "2": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:isPrototypeGet;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "3": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = ;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "4": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?isGlobalExpr:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "5": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?ref:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "6": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:isGlobalExpr;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "7": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:ref;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "8": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?moduleGraph:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "9": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:moduleGraph;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "10": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nfinal Name owner = (true)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "11": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "12": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((moduleGraph != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "13": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?owner:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "14": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nreturn;\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "15": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?parent:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "16": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = ref.getModule();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "17": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = name.getRefs();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "18": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nboolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "19": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "20": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = this.name;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "21": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:owner;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "22": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?declaration:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "23": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = !isTypedef(ref);\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "24": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = name;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "25": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (Name)parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "26": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:declaration;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "27": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?source:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "28": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((name != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "29": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (-1)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "30": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (1)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "31": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = declaration.getModule();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "32": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?node:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "33": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:source;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "34": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (Name)name;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "35": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (name)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "36": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = owner.getDeclaration();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "37": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:node;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "38": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = compiler.getModuleGraph();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "39": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = new Name();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "40": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nreportRefToUndefinedName(name, ref);\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "41": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((moduleGraph != 0)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "42": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (-false)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "43": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((parent != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "44": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((ref != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "45": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nreportBadModuleReference(name, ref);\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "46": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif(((declaration != null) && (ref.getModule() != declaration.getModule()))){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "47": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((owner != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "48": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif(((owner != null) && (owner.getDeclaration() != null))){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "49": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "50": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\ncompiler.report(JSError.make(ref.source.getName(), ref.node, NAME_DEFINED_LATE_WARNING, refName, owner.getFullName(), owner.getDeclaration().source.getName(), String.valueOf(owner.getDeclaration().node.getLineno())));\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "51": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((moduleGraph == null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "52": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((owner.getDeclaration() != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "53": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (true)?name:name;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "54": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((declaration != null)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "55": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((owner.localSets == 0)){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "56": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = ((name == null))?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "57": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nString refName = (isPrototypeGet)?(name.getFullName() + \"null\"):name.getFullName();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "58": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif((ref.getModule() != declaration.getModule())){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "59": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = (-true)?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "60": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nbreak;\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "61": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nboolean singleGlobalParentDecl = (((owner != null) && (owner.getDeclaration() != null)) && (owner.localSets == 0));\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "62": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nJSModuleGraph moduleGraph = compiler.getModuleGraph();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "63": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif(!isPrototypeGet){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "64": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nboolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "65": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName parent = name.parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "66": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nName owner = ((name != null))?name:parent;\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }",
          "67": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nif(!isGlobalExpr){\n          Name owner = true ? name : parent;          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n}\n        }\n      }\n    }\n  }",
          "68": "  private void validateName(Name name, boolean isDefined) {\n    // If the name is not defined, emit warnings for each reference. While\n    // we're looking through each reference, check all the module dependencies.\n    Ref declaration = name.getDeclaration();\n    Name parent = name.parent;\n\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    for (Ref ref : name.getRefs()) {\n      // Don't worry about global exprs.\n      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n\n      if (!isDefined && !isTypedef(ref)) {\n        if (!isGlobalExpr) {\n          reportRefToUndefinedName(name, ref);\n        }\n      } else if (declaration != null &&\n          ref.getModule() != declaration.getModule() &&\n          !moduleGraph.dependsOn(\n              ref.getModule(), declaration.getModule())) {\n        reportBadModuleReference(name, ref);\n      } else {\n        // Check for late references.\n        if (ref.scope.isGlobal()) {\n          // Prototype references are special, because in our reference graph,\n          // A.prototype counts as a reference to A.\n          boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET);\nRef declaration = name.getDeclaration();\n          boolean singleGlobalParentDecl =\n              owner != null &&\n              owner.getDeclaration() != null &&\n              owner.localSets == 0;\n\n          if (singleGlobalParentDecl &&\n              owner.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n            String refName = isPrototypeGet\n                ? name.getFullName() + \".prototype\"\n                : name.getFullName();\n            compiler.report(\n                JSError.make(ref.source.getName(), ref.node,\n                    NAME_DEFINED_LATE_WARNING,\n                    refName,\n                    owner.getFullName(),\n                    owner.getDeclaration().source.getName(),\n                    String.valueOf(owner.getDeclaration().node.getLineno())));\n          }\n        }\n      }\n    }\n  }"
}