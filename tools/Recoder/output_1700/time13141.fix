{
          "0": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", true, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "1": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, true);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "2": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "3": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbreak;\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "4": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 0, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "5": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, \"null\", -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "6": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, null, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "7": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "8": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, null);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "9": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, \"null\");\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "10": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneId();\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "11": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", true, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "12": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", null, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "13": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", \"null\", 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "14": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 1, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "15": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneShortName(null);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "16": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneName();\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "17": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "18": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(true, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "19": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, 1);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "20": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneId();\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "21": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", true, 2, 2);\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "22": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", 0, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "23": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(false, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "24": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, true, false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "25": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneShortName(null);\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "26": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", 1, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "27": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nreturn;\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "28": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneName();\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "29": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneId(null, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "30": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendLiteral(new String(sub));\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "31": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, false, false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "32": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneName(null, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "33": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\ncontinue;\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "34": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "35": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, -1, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "36": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, false, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "37": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, -1);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "38": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, -2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "39": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nif((tokenLen == 1)){\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n}\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "40": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneShortName(null, \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "41": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "42": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, 2, false);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "43": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", -1, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "44": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "45": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(\"null\", \"null\", false, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "46": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", 2, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "47": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", -2, 2, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "48": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nif((tokenLen == 2)){\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n}\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "49": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", false, true, -2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "50": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, -2);                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "51": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "52": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, null);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "53": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "54": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "55": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 1, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "56": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 0, 1);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "57": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "58": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, null, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "59": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(\"null\", null, 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "60": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, 0, 1);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "61": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, 0, 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "62": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, null, null);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "63": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, false, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "64": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 1, 1);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "65": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(\"null\", \"null\", 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "66": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, \"null\", null, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "67": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, true, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "68": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, null, false);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "69": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, 0, 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
          "70": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\nbuilder.appendTimeZoneOffset(null, null, null, 0, 0, 0);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }"
}