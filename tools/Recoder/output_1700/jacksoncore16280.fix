{
          "0": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) || (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "1": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "2": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ptr >= 5)){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "3": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ptr < end)){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "4": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr >= end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "5": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr <= end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "6": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 0) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "7": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 0xFF) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "8": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr <= 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "9": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 1) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "10": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 2) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "11": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr > end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "12": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr > 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "13": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr < 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "14": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 4) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "15": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < end))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "16": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 0xF) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "17": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= -1) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "18": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((((ptr >= 5) && (ptr < end)) && (ptr < end))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "19": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 8) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "20": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr == end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "21": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr >> end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "22": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < ptr))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "23": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < ch))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "24": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr == 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "25": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < HEX_CHARS))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "26": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr < hi))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "27": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ch < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "28": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr - end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "29": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && ((ptr >= 5) && (ptr < end)))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "30": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >> 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "31": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr >>> end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "32": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ch > 0xFF)){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "33": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (end < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "34": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (hi < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "35": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr != end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "36": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (HEX_CHARS < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "37": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr - 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "38": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr >= 5))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "39": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr != 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "40": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ch > 0xFF)){\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n}\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "41": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >>> 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "42": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nptr -= 6;\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "43": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((((ptr >= 5) && (ptr < end)) && (ptr >= 5))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "44": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((((ptr >= 5) && (ptr < end)) && ((ch >> 8) & 0xFF))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "45": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((((ptr >= 5) && (ptr < end)) && (ch > 0xFF))){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "46": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nbuffer[ptr++] = HEX_CHARS[(hi >> 4)];\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "47": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) != (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "48": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nch &= 0xFF;\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "49": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nbuffer[ptr++] = \"null\";\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "50": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nbuffer[ptr++] = HEX_CHARS[(hi & 0xF)];\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "51": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) && (ptr % end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "52": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nbuffer[ptr] = HEX_CHARS[(ch & 0xF)];\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "53": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(ptr){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "54": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) | (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "55": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ch >> 8)){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "56": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ptr < end)){\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n}\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "57": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr % 5) && (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "58": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ptr >= 5)){\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n}\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "59": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) + (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "60": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif((ch & 0xF)){\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "61": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nif(((ptr >= 5) == (ptr < end))){                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "62": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\nreturn;\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "63": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr >= 5 && ptr < end) { // fits, prepend to buffer                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }"
}