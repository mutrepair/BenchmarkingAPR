{
          "0": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] >= PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "1": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] > PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "2": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] <= PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "3": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] < PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "4": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "5": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == lastData)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "6": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((lastData == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "7": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((lastData - 0)){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "8": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] != PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "9": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == decodedData)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "10": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((decodedData == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "11": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == numberQuadruple)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "12": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((decodedData[(lastData - 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "13": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((lastData - numberQuadruple)){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "14": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == PAD)){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "15": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == CHUNK_SEPARATOR)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "16": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == base64Alphabet)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "17": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == lookUpBase64Alphabet)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "18": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == decodedData[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "19": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((numberQuadruple == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "20": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\n                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "21": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((PAD[(lastData - 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "22": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData >= 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "23": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == PAD[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "24": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == CHUNK_SEPARATOR[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "25": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == base64Alphabet[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "26": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == lookUpBase64Alphabet[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "27": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((numberQuadruple[(lastData - 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "28": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == base64Data[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "29": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] || PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "30": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == numberQuadruple[(lastData - 0)])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "31": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == base64Data)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "32": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "33": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == )){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "34": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((PAD == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "35": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] && PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "36": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(( == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "37": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == )){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "38": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData <= 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "39": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData > 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "40": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "41": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(lastData){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "42": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(( == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "43": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData == 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "44": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == PAD)){\nif((--lastData == 0)){\nreturn new byte[0];\n}\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "45": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] == base64Data[0])){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "46": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] - PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "47": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\ndecodedData = new byte[(lastData - numberQuadruple)];\n            while (base64Data[lastData - 0] == PAD) {                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "48": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData != 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "49": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nif((lastData != null)){\n            while (base64Data[lastData - 0] == PAD) {                if (--lastData == 0) {\n                    return new byte[0];\n                }\n}\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "50": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData < 0)] == PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "51": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile((base64Data[(lastData - 0)] + PAD)){                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "52": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nreturn new byte[0];            while (base64Data[lastData - 0] == PAD) {                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "53": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "54": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nbreak;\n            while (base64Data[lastData - 0] == PAD) {                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "55": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "56": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((lastData != null) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "57": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData == base64Data))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "58": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((lastData == base64Data) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "59": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD < lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "60": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((PAD == PAD) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "61": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData != lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "62": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "63": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data == PAD) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "64": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (base64Data == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "65": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data == base64Data) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "66": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "67": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((lastData == 0) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "68": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((PAD == base64Data) && (base64Data[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "69": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (decodedData == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "70": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData < lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "71": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (lastData == 0))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "72": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (base64Data == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "73": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nreturn;\n            while (base64Data[lastData - 0] == PAD) {                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "74": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD == base64Data))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "75": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (base64Data == base64Data))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "76": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD < PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "77": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (decodedData == decodedData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "78": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (numberQuadruple == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "79": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) || (lastData == lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "80": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (decodedData == numberQuadruple))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "81": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD != lastData))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "82": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (base64Data[(lastData - 0)] == base64Data))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }",
          "83": "    public static byte[] decodeBase64(byte[] base64Data) {\n        // RFC 2045 requires that we discard ALL non-Base64 characters\n        base64Data = discardNonBase64(base64Data);\n\n        // handle the edge case, so we don't have to worry about it later\n        if (base64Data.length == 0) {\n            return new byte[0];\n        }\n\n        int numberQuadruple = base64Data.length / FOURBYTE;\n        byte decodedData[] = null;\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n\n        // Throw away anything not in base64Data\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        {\n            // this sizes the output array properly - rlw\n            int lastData = base64Data.length;\n            // ignore the '=' padding\nwhile(((base64Data[(lastData - 0)] == PAD) && (PAD[(lastData - 0)] == PAD))){\n\n}                if (--lastData == 0) {\n                    return new byte[0];\n                }\n            }\n            decodedData = new byte[lastData - numberQuadruple];\n        }\n\n        for (int i = 0; i < numberQuadruple; i++) {\n            dataIndex = i * 4;\n            marker0 = base64Data[dataIndex + 2];\n            marker1 = base64Data[dataIndex + 3];\n\n            b1 = base64Alphabet[base64Data[dataIndex]];\n            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n\n            if (marker0 != PAD && marker1 != PAD) {\n                // No PAD e.g 3cQl\n                b3 = base64Alphabet[marker0];\n                b4 = base64Alphabet[marker1];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n            } else if (marker0 == PAD) {\n                // Two PAD e.g. 3c[Pad][Pad]\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n            } else if (marker1 == PAD) {\n                // One PAD e.g. 3cQ[Pad]\n                b3 = base64Alphabet[marker0];\n\n                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            }\n            encodedIndex += 3;\n        }\n        return decodedData;\n    }"
}