{
          "0": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset < len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "1": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset > len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "2": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "3": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset >= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "4": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset || len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "5": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset && len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "6": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((escLen <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "7": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= escLen)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "8": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset == len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "9": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((start <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "10": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= start)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "11": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwriteStartArray();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "12": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwriteEndArray();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "13": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwriteStartObject();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "14": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwriteEndObject();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "15": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwriteNull();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "16": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nflush();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "17": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nclose();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "18": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_releaseBuffers();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "19": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_writeNull();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "20": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_flushBuffer();\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "21": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(offset){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "22": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((c < escLen)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "23": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_writeStringCustom(text, offset, len);\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "24": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((escCodes <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "25": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "26": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= escCodes)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "27": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset != len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "28": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nreturn;\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "29": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((escCodes[c] != 0)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "30": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset || (offset <= len))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "31": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(len){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "32": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((_outputTail + newAmount)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "33": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((c < escLen)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "34": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset | len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "35": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nlen += offset;\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "36": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((text <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "37": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((_outputTail + newAmount)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "38": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((escCodes[c] != 0)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "39": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset - len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "40": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= text)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "41": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((len || (offset <= len))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "42": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset && (offset <= len))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "43": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(!offset){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "44": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(text){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "45": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "46": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nSystem.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "47": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_appendCharacterEscape(c, escCodes[c]);\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "48": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(!len){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "49": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= offset)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "50": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(writeNumber(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "51": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeQuotedInt(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "52": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeString2(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "53": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeSegment(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "54": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeStringCustom(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "55": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeSegmentCustom(offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "56": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_outputTail += newAmount;\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "57": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nstart++;\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "58": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n_writer.write(text, start, newAmount);\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "59": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(((c < escLen) && (escCodes[c] != 0))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "60": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((++offset >= len)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "61": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((++offset >= len)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "62": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif(true){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "63": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((len && (offset <= len))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "64": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((_characterEscapes != null)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "65": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((_maximumNonEscapedChar != 0)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "66": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((_characterEscapes != null)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "67": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif(((c < escLen) && (escCodes[c] != 0))){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "68": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((SHORT_WRITE <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "69": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((escLen != 0)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "70": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= SHORT_WRITE)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "71": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((_maximumNonEscapedChar != 0)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "72": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset < offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "73": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeStringASCII(offset, offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "74": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(_writeSegmentASCII(offset, offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "75": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nbreak;\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "76": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif(((_outputTail + newAmount) > _outputEnd)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "77": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= _outputTail)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "78": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((len <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "79": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nif((newAmount < SHORT_WRITE)){\n        while (offset <= len) {            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n}\n    }",
          "80": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((_outputTail <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "81": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= _outputBuffer)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "82": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset <= _outputEscapes)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "83": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((_outputBuffer <= len)){            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "84": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile((offset > offset)){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }",
          "85": "    private void _writeString(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\nwhile(((offset <= len) || (offset < offset))){\n\n}            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }"
}