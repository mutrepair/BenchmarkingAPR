{
          "0": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\noutputFullTriplet(triplet, buffer, ptr);\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "1": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nvalue = newValue;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "2": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nvalue = -value;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "3": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nptr -= 3;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "4": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\noffset += calcLongStrLength(value);\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "5": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn offset;                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "6": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\noutputLeadingTriplet(ivalue, buffer, origOffset);\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "7": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nivalue = newValue;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "8": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nbreak;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "9": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn outputInt((int)value, buffer, offset);                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "10": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn outputInt((int)value, buffer, offset);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "11": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "12": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn offset;            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "13": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (newValue * 1000);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "14": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset + len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "15": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (newValue * THOUSAND_L);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "16": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (ivalue >= 1000);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "17": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (ivalue - (newValue * 1000));            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "18": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn 0;                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "19": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset <= len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "20": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (ivalue / 1000);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "21": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn len;            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "22": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (value / THOUSAND_L);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "23": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((newValue * 1000)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "24": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\ncontinue;\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "25": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((newValue * THOUSAND_L)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "26": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (len - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "27": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset >= len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "28": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((value <= MAX_INT_AS_LONG)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "29": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "30": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\ncontinue;\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "31": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (value < 0L);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "32": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (value > MIN_INT_AS_LONG);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "33": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset / len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "34": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((value > MIN_INT_AS_LONG)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "35": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((value < 0L)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "36": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset == len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "37": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (origOffset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "38": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((value == Long.MIN_VALUE)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "39": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "40": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset - origOffset);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "41": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn ( - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "42": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset * len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "43": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "44": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset - );            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "45": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((ivalue >= 1000)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "46": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset % len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "47": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset > len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "48": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nreturn (offset != len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "49": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nbreak;\n            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "50": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((len != null)){\n}\n                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }",
          "51": "    public static int outputLong(long value, char[] buffer, int offset)\n    {\n        // First: does it actually fit in an int?\n        if (value < 0L) {\n            /* MIN_INT is actually printed as long, just because its\n             * negation is not an int but long\n             */\n            if (value > MIN_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n            if (value == Long.MIN_VALUE) {\n                // Special case: no matching positive value within range\n                int len = SMALLEST_LONG.length();\n                SMALLEST_LONG.getChars(0, len, buffer, offset);\nif((len > 0)){\nreturn 0;}                return (offset - len);            }\n            buffer[offset++] = '-';\n            value = -value;\n        } else {\n            if (value <= MAX_INT_AS_LONG) {\n                return outputInt((int) value, buffer, offset);\n            }\n        }\n\n        /* Ok: real long print. Need to first figure out length\n         * in characters, and then print in from end to beginning\n         */\n        int origOffset = offset;\n        offset += calcLongStrLength(value);\n        int ptr = offset;\n\n        // First, with long arithmetics:\n        while (value > MAX_INT_AS_LONG) { // full triplet\n            ptr -= 3;\n            long newValue = value / THOUSAND_L;\n            int triplet = (int) (value - newValue * THOUSAND_L);\n            outputFullTriplet(triplet, buffer, ptr);\n            value = newValue;\n        }\n        // Then with int arithmetics:\n        int ivalue = (int) value;\n        while (ivalue >= 1000) { // still full triplet\n            ptr -= 3;\n            int newValue = ivalue / 1000;\n            int triplet = ivalue - (newValue * 1000);\n            outputFullTriplet(triplet, buffer, ptr);\n            ivalue = newValue;\n        }\n        // And finally, if anything remains, partial triplet\n        outputLeadingTriplet(ivalue, buffer, origOffset);\n\n        return offset;\n    }"
}