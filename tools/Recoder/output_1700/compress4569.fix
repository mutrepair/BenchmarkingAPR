{
          "0": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) > 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "1": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) < 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "2": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal long hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "3": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag > ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "4": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag < ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "5": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) == 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "6": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) >= 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "7": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) <= 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "8": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag == ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "9": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "10": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) || 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "11": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag >= ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "12": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag <= ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "13": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) && 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "14": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag != ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "15": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag || ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "16": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag && ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "17": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | cfh) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "18": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipEncodingHelper.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "19": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) & 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "20": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal int hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "21": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) | 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "22": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "23": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "24": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | e) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "25": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "26": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | UTF8_ZIP_ENCODING) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "27": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | off) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "28": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean hasEFS = ((generalPurposeFlag | ZipEncodingHelper.UTF8_ZIP_ENCODING) != 0);\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "29": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nfinal boolean  = ZipArchiveOutputStream.EFS_FLAG;\n            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "30": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\nreturn;\n            final boolean hasEFS = \n                (generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) != 0;            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }",
          "31": "    private Map populateFromCentralDirectory()\n        throws IOException {\n        HashMap noEFS = new HashMap();\n\n        positionAtCentralDirectory();\n\n        byte[] cfh = new byte[CFH_LEN];\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n        if (sig != cfhSig && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n        while (sig == cfhSig) {\n            archive.readFully(cfh);\n            int off = 0;\n            ZipArchiveEntry ze = new ZipArchiveEntry();\n\n            int versionMadeBy = ZipShort.getValue(cfh, off);\n            off += SHORT;\n            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n            off += SHORT; // skip version info\n\n            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\n            final boolean hasEFS = \n                (generalPurposeFlag | ZipArchiveOutputStream.EFS_FLAG) != 0;            final ZipEncoding entryEncoding =\n                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n\n            off += SHORT;\n\n            ze.setMethod(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            // FIXME this is actually not very cpu cycles friendly as we are converting from\n            // dos to java while the underlying Sun implementation will convert\n            // from java to dos time for internal storage...\n            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n            ze.setTime(time);\n            off += WORD;\n\n            ze.setCrc(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            ze.setSize(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            int fileNameLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int extraLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            int commentLen = ZipShort.getValue(cfh, off);\n            off += SHORT;\n\n            off += SHORT; // disk number\n\n            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n            off += SHORT;\n\n            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n            off += WORD;\n\n            byte[] fileName = new byte[fileNameLen];\n            archive.readFully(fileName);\n            ze.setName(entryEncoding.decode(fileName));\n\n            // LFH offset,\n            OffsetEntry offset = new OffsetEntry();\n            offset.headerOffset = ZipLong.getValue(cfh, off);\n            // data offset will be filled later\n            entries.put(ze, offset);\n\n            nameMap.put(ze.getName(), ze);\n\n            byte[] cdExtraData = new byte[extraLen];\n            archive.readFully(cdExtraData);\n            ze.setCentralDirectoryExtra(cdExtraData);\n\n            byte[] comment = new byte[commentLen];\n            archive.readFully(comment);\n            ze.setComment(entryEncoding.decode(comment));\n\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n\n            if (!hasEFS && useUnicodeExtraFields) {\n                noEFS.put(ze, new NameAndComment(fileName, comment));\n            }\n        }\n        return noEFS;\n    }"
}