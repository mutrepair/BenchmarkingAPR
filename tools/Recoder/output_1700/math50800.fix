{
          "0": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / jBlock)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "1": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (jBlock / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "2": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (jBlock / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "3": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock <= (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "4": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn <= BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "5": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / p)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "6": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (0 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "7": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / jWidth)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "8": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "9": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / rows)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "10": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / columns)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "11": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / blockRows)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "12": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / blockColumns)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "13": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn >= BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "14": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock >= (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "15": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / startColumn)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "16": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "17": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / iBlock)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "18": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / endColumn)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "19": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / p0)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "20": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock - (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "21": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(1 % (endColumn / BLOCK_SIZE));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "22": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (jWidth / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "23": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (p / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "24": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn - BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "25": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (jWidth / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "26": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (BLOCK_SIZE / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "27": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (p / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "28": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (2 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "29": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (BLOCK_SIZE / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "30": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (endColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "31": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (startColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "32": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock > (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "33": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (iBlock / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "34": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / -jBlock)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "35": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (iBlock / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "36": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nvisitor.visit(p, q, block[k]);\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "37": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int q = qStart;(q < qEnd);++q) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "38": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));p) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "39": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nif((p != null)){\ncontinue;\n}\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "40": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(p < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "41": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn < BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "42": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock / (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "43": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(endColumn / BLOCK_SIZE);++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "44": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\n++k;\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "45": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nreturn;\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "46": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(startColumn / BLOCK_SIZE);++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "47": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int p = pStart;(p < pEnd);++p) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "48": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));jWidth) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "49": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn >> BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "50": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jWidth < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "51": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock * (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "52": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn > BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "53": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock < (1 % (endColumn / BLOCK_SIZE))));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "54": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nbreak;\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "55": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(endColumn < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "56": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(BLOCK_SIZE < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "57": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock >> (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "58": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (1 % (endColumn / BLOCK_SIZE)));p0) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "59": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(startColumn < (1 % (endColumn / BLOCK_SIZE)));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "60": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (startColumn / BLOCK_SIZE));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "61": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nif((p != null)){\ncontinue;\n}                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "62": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nif((p == 0)){\ncontinue;\n}\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 % (endColumn / BLOCK_SIZE); ++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "63": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - BLOCK_SIZE));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "64": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - jBlock));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "65": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (BLOCK_SIZE - jBlock));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "66": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (endColumn - jBlock));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "67": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (startColumn - jBlock));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "68": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - endColumn));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "69": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - 0));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "70": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - startColumn));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "71": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (BLOCK_SIZE - BLOCK_SIZE));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "72": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (BLOCK_SIZE - endColumn));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "73": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (jBlock - 1));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "74": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (endColumn - BLOCK_SIZE));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "75": "    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                            final int startRow, final int endRow,\n                            final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int p = pStart; p < pEnd; ++p) {\nfor(int jBlock = (startColumn / BLOCK_SIZE);(jBlock < (endColumn - endColumn));++jBlock) {                    final int jWidth = blockWidth(jBlock);\n                    final int q0     = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }"
}