{
          "0": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "1": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 2;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "2": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 3;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "3": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = false;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "4": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = null;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "5": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nlong outputCount = 1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "6": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = -1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "7": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = true;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "8": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = \"null\";\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "9": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "10": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint  = ;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "11": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nfinal int outputCount = 1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "12": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = -2;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "13": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "14": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint  = ;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "15": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_closeInput();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "16": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_releaseBuffers();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "17": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nclose();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "18": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_finishString();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "19": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_finishString2();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "20": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipString();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "21": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipCR();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "22": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipLF();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "23": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipComment();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "24": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipCComment();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "25": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n_skipCppComment();\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "26": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "27": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "28": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = -0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "29": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint  = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "30": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint outputCount = 2;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "31": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "32": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nint  = 1;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "33": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\nreturn;\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }",
          "34": "    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 1;\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }"
}