{
          "0": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "1": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- == -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "2": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- <= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "3": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- > -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "4": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- != -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "5": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= 0)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "6": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- < -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "7": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((ch & 0xff)){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "8": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= 0xff)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "9": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "10": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= -1)){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "11": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((ll8 >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "12": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((lastShadow >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "13": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= -2)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "14": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((ch >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "15": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= 2)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "16": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((unzftab >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "17": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= 1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "18": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) && (s-- >= -1))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "19": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s + 1)){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "20": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- && -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "21": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- & -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "22": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= -0)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "23": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >> -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "24": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >>> -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "25": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\ndo{\n}while((ch & 0xff))\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "26": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nif((ch & 0xff)){\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "27": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((s-- >= null)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "28": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) || (s-- >= -1))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "29": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nif((s-- >= -1)){\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "30": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nif(bsGetBit()){\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "31": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((-lastShadow >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "32": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((-ll8 >= -1)){                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "33": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile((lastShadow >= limitLast)){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "34": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n(;;)                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "35": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nreturn;\n                while (s-- >= -1) {                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "36": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) && (ch > ch))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "37": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) && (ch < ch))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "38": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) && (ll8 > ch))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "39": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nwhile(((s-- >= -1) && (ll8 < ch))){\n\n}                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "40": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\nbreak;\n                while (s-- >= -1) {                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "41": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\ncontinue;\n                while (s-- >= -1) {                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }",
          "42": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= -1) {                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }"
}