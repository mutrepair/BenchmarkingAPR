{
          "0": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "1": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "2": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((2 * rho) * zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "3": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nr[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "4": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ntheta[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "5": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphi[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "6": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\njacobian[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "7": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nrHessian[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "8": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nthetaHessian[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "9": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nx[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "10": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ny[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "11": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nz[-2].[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "12": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nr = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "13": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ntheta = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "14": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphi = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "15": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\njacobian = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "16": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nrHessian = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "17": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nthetaHessian = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "18": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "19": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nx = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "20": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ny = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "21": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nz = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "22": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) - r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "23": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (2 * rho);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "24": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((0 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "25": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) & r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "26": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) | r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "27": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / r[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "28": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / theta[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "29": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phi[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "30": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / jacobian[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "31": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / rHessian[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "32": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / thetaHessian[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "33": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phiHessian[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "34": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / x[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "35": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / y[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "36": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / z[-2].[2]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "37": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * phiHessian[2].[1]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "38": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) * r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "39": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / theta);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "40": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phi);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "41": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / jacobian);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "42": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / rHessian);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "43": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / thetaHessian);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "44": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phiHessian);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "45": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / x);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "46": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / y);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "47": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / z);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "48": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((1 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "49": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) < r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "50": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nr[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "51": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ntheta[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "52": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphi[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "53": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\njacobian[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "54": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nrHessian[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "55": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nthetaHessian[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "56": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "57": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nx[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "58": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\ny[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "59": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nz[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "60": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * phiHessian[2].[1]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "61": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] += (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "62": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) << r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "63": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * phiHessian[-2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "64": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * phiHessian[-2].[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "65": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) <= r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "66": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rho[2].[1]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "67": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * phiHessian[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "68": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3[2].[1]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "69": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3[-2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "70": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "71": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * phiHessian[-2].[2]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "72": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) > r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "73": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "74": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rho[-2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "75": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho[2].[1]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "76": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] += ((2 * rho) * zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "77": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "78": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rho[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "79": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * r[2].[1]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "80": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * zOr3[2].[1]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "81": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * phiHessian) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "82": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * phiHessian[-2]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "83": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3[-2].[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "84": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nzOr3[-2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "85": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nrho[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "86": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nzOr3[2].[1] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "87": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * -phiHessian) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "88": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phiHessian[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "89": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * phiHessian[2]) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "90": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nzOr3[2] = (((2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "91": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rho[-2].[2]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "92": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rhor4[2].[1]) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "93": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / r[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "94": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / theta[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "95": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / phi[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "96": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / jacobian[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "97": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / rHessian[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "98": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / thetaHessian[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "99": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / x[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "100": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / y[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "101": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * zOr3) / z[2].[1]);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "102": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) * rhor4) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "103": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((2 * rho) * zOr3) / r) + 1);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "104": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[0].[1] = phiHessian[1].[0];\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "105": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((-2 * rho) * zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "106": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "107": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[2].[1] = ((y * (rho2 - z2)) / rhor4);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "108": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((2 * rho) - zOr3) / r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "109": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((zOr3 * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "110": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((zOr3 * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "111": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((zOr3 * rho) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "112": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((rho * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "113": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nreturn;\n            phiHessian[-2][2] = 2 * rho * zOr3 / r;\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "114": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((zOr3 * zOr3) * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "115": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((rho * zOr3) * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "116": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((zOr3 * zOr3) * zOr3) + rho);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "117": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((zOr3 * rho) * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "118": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = (((zOr3 * zOr3) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "119": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[-2][2] = 2 * rho * zOr3 / r;\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "120": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((zOr3 * zOr3) * zOr3) * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "121": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((zOr3 * zOr3) * zOr3) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "122": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((rho * zOr3) * zOr3) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "123": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((zOr3 * 1) * zOr3) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "124": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((zOr3 * zOr3) * zOr3) * rho) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "125": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((rho * zOr3) * zOr3) * zOr3) + zOr3);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "126": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 + z * zOr3;\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\nphiHessian[-2].[2] = ((((phiHessian * zOr3) * zOr3) * zOr3) + r);\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }"
}