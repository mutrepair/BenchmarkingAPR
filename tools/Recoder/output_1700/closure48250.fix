{
          "0": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "1": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new long[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "2": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "3": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nlong out = new int[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "4": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(n - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "5": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[[]];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "6": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = 0;\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "7": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m + n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "8": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m <= n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "9": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = 1;\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "10": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[0];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "11": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[][(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "12": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m / n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "13": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[1];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "14": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m >= n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "15": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[][[]];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "16": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nfinal int[] out = new int[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "17": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[n];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "18": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m * n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "19": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = ;\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "20": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[][(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "21": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m < n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "22": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m > n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "23": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[m];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "24": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint out = new int[(m - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "25": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m == n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "26": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[] out = new int[(m % n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "27": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint i = 0,i = 0,i = 0;\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "28": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nreturn;\n    int[] out = new int[m - n];\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "29": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[(n - n)];\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "30": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\n    int[] out = new int[m - n];\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "31": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "32": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[(m - n)]{(n - n)};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "33": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "34": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = new int[(m - n)]{(n - n),n};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "35": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "36": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "37": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "38": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "39": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "40": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "41": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "42": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }",
          "43": "  public CharRanges union(CharRanges other) {\n    // Index of the input ranges\n    int[] q = this.ranges, r = other.ranges;\n    // Lengths of the inputs\n    int m = q.length, n = r.length;\n\n    if (m == 0) { return other; }\n    if (n == 0) { return this; }\n\n    // The output array.  The length is m+n in the worst case when all the\n    // ranges in a are disjoint from the ranges in b.\nint[]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};\n\n    // Indexes into the various arrays\n    int i = 0, j = 0, k = 0;\n    // Since there are three arrays, and indices into them the following\n    // should never occur in this function:\n    // (1) q[j] or q[k]                         -- q is indexed by i\n    // (2) r[i] or r[k]                         -- r is indexed by j\n    // (3) out[i] or out[j]                     -- out is indexed by k\n    // (4) i < n or j < m                       -- index compared to wrong limit\n\n    // This loop exits because we always increment at least one of i,j.\n    while (i < m && j < n) {\n      // Range starts and ends.\n      int a0 = q[i], a1 = q[i + 1],\n          b0 = r[j], b1 = r[j + 1];\n      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n        out[k++] = a0;\n        out[k++] = a1;\n        i += 2;\n      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n        out[k++] = b0;\n        out[k++] = b1;\n        j += 2;\n      } else {  // ranges overlap\n        // We need to compute a new range based on the set of ranges that\n        // transitively overlap.\n        //       AAAAAAAAA AAA\n        //     BBB  BBB* BBB\n        // In the range above, the start comes from one set, and the end from\n        // another.  The range with the asterisk next to it is subsumed entirely\n        // by a range from the other, and so not all ranges on the input\n        // contribute a value to the output.\n        // The last BBB run serves only as a bridge -- it overlaps two\n        // disjoint ranges in the other one so establishes that they\n        // transitively overlap.\n        int start = Math.min(a0, b0);\n        // Guess at the end, and lookahead to come up with a more complete\n        // estimate.\n        int end = Math.max(a1, b1);\n        i += 2;\n        j += 2;\n        while (i < m || j < n) {\n          if (i < m && q[i] <= end) {\n            end = Math.max(end, q[i + 1]);\n            i += 2;\n          } else if (j < n && r[j] <= end) {\n            end = Math.max(end, r[j + 1]);\n            j += 2;\n          } else {\n            break;\n          }\n        }\n        out[k++] = start;\n        out[k++] = end;\n      }\n    }\n    // There may be unprocessed ranges at the end of one of the inputs.\n    if (i < m) {\n      System.arraycopy(q, i, out, k, m - i);\n      k += m - i;\n    } else if (j < n) {\n      System.arraycopy(r, j, out, k, n - j);\n      k += n - j;\n    }\n    // We guessed at the output length above.  Cut off the tail.\n    if (k != out.length) {\n      int[] clipped = new int[k];\n      System.arraycopy(out, 0, clipped, 0, k);\n      out = clipped;\n    }\n    return new CharRanges(out);\n  }"
}