{
          "0": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((jWidth / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "1": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((qStart / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "2": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nfinal int k = ((((p / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "3": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((q0 / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "4": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "5": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((jBlock / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "6": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p0 / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "7": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / jWidth) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "8": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / qStart) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "9": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "10": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - jWidth);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "11": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((block / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "12": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = ((((p / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "13": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * qStart) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "14": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / q0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "15": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) + q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "16": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + jWidth) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "17": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) - qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "18": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / jBlock) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "19": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((qEnd / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "20": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p - p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "21": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * q0) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "22": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - jBlock);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "23": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nvisitor.visit(p, q, block[k]);\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "24": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - p0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "25": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + q0) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "26": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((iBlock / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "27": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jBlock) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "28": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nlong k = ((((p / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "29": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - block);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "30": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * p0) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "31": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((BLOCK_SIZE / p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "32": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / block) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "33": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + jBlock) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "34": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n++k;\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "35": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) / q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "36": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + p0) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "37": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * block) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "38": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - qEnd);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "39": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / qEnd) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "40": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nif((p != null)){\ncontinue;\n}\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "41": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) * q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "42": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((p / p0) * jWidth) + qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "43": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + block) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "44": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p + p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "45": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * qEnd) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "46": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / iBlock) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "47": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = ((p / p0) * jWidth);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "48": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - iBlock);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "49": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nbreak;\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "50": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / BLOCK_SIZE) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "51": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qEnd) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "52": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (p / p0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "53": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) - BLOCK_SIZE);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "54": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) / qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "55": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nreturn;\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "56": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * iBlock) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "57": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) <= q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "58": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) + qStart) % q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "59": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p / p0) * jWidth) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "60": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint k = ((((p * p0) * jWidth) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "61": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\ncontinue;\n                    int k = (p / p0) * jWidth + qStart - q0;                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "62": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "63": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart * qStart) * qStart) * qStart) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "64": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "65": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) / qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "66": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart * qStart) * qStart) * qStart) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "67": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart * qStart) * qStart) * qStart) / qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "68": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * q0) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "69": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) / qStart) + qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "70": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) + qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "71": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) + qStart) - (qStart - qStart));\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "72": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((qStart / qStart) * qStart) * qStart) * qStart) - (qStart - qStart));\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "73": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) * qStart) * qStart) * qStart) * q0) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "74": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) * qStart) * qStart) * qStart) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "75": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) / qStart) * qStart) * qStart) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "76": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) * qStart) * qStart) * q0) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "77": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) / qStart) * qStart) * q0) * qStart) - q0);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "78": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) * qStart) * qStart) * qStart) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "79": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) / qStart) * qStart) * qStart) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "80": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) * qStart) * qStart) * q0) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "81": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) / qStart) / qStart) * qStart) * q0) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "82": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) * qStart) * qStart) * qStart) * qStart) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "83": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0     = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int q0     = jBlock * BLOCK_SIZE;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final T[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\nint p0 = (((((((qStart / qStart) * qStart) / qStart) * qStart) * qStart) * qStart) - qStart);\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }"
}