{
          "0": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)max | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "1": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] | 2);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "2": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_closeInput();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "3": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_releaseBuffers();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "4": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nclose();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "5": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_isNextTokenNameYes();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "6": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_finishString();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "7": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipString();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "8": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "9": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipCComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "10": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipCppComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "11": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipCR();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "12": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_skipLF();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "13": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "14": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nfinal int c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "15": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "16": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)max[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "17": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nreturn;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "18": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] | 0);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "19": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)codes[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "20": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] << 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "21": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] >>> 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "22": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] & 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "23": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "24": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nbreak;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "25": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)outPtr[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "26": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)ptr[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "27": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)outBuf[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "28": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)codes | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "29": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] < 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "30": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nptr = _inputPtr;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "31": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nloadMoreGuaranteed();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "32": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] >> 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "33": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] - 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "34": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nlong c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "35": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] / 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "36": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_inputPtr = (ptr + 1);\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "37": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)ptr | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "38": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)_inputPtr | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "39": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nchar[] c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "40": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n++ptr;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "41": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\noutBuf[outPtr++] = (char)c;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "42": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] <= 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "43": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)_inputPtr[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "44": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)outPtr | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "45": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._closeInput();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "46": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._releaseBuffers();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "47": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer.close();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "48": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._isNextTokenNameYes();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "49": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._finishString();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "50": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipString();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "51": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "52": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipCComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "53": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipCppComment();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "54": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipCR();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "55": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer._skipLF();\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "56": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = 1;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "57": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_finishString2(outBuf, outPtr);\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "58": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)_inputBuffer | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "59": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_inputPtr = ptr;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "60": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint[] c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "61": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)outBuf | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "62": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)INT_QUOTE[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "63": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[outPtr++] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "64": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n_textBuffer.setCurrentLength(outPtr);\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "65": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nif((c == INT_QUOTE)){\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "66": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[c] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "67": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[((int)inputBuffer[ptr] | 255)] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "68": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] | -1);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "69": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = (((int)inputBuffer[ptr] | 255) * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "70": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = 2;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "71": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\ncontinue;\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "72": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nif((ptr >= _inputEnd)){\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "73": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nbyte[] c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "74": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nif((codes[c] != 0)){\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "75": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = (((int)inputBuffer[ptr] | 255) | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "76": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nif((max != null)){\n            int c = (int)inputBuffer[ptr] | 255;            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "77": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = _textBuffer.emptyAndGetCurrentSegment();\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "78": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = inputBuffer[ptr];\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "79": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "80": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)ptr[((int)inputBuffer[ptr] | 255)] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "81": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[1] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "82": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nchar c = ((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "83": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = (max * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "84": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nfinal byte[] inputBuffer = _inputBuffer;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "85": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "86": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nfinal int[] codes = sInputCodesUtf8;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "87": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint outPtr = 0;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "88": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((int)inputBuffer[ptr] | 1);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "89": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = (((int)inputBuffer[ptr] | 255) * max);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "90": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((((int)inputBuffer[ptr] | 255) * 255) * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "91": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((((int)inputBuffer[ptr] | 255) * 255) | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "92": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((inputBuffer * 255) * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "93": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((inputBuffer * 255) | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "94": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((max * 255) * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "95": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = (((((int)inputBuffer[ptr] | 255) * 255) * 255) * 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }",
          "96": "    protected void _finishString()\n        throws IOException, JsonParseException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = sInputCodesUtf8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\nint c = ((((int)inputBuffer[ptr] | 255) && (inputBuffer == 0)))?inputBuffer[ptr]:((int)inputBuffer[ptr] | 255);\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }"
}