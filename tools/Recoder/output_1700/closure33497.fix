{
          "0": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(true){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "1": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(false){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "2": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nreturn;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "3": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(ifNode.getNext()){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "4": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(-true){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "5": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nexitNode = exitNodeParent.getLastChild();\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "6": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(\"null\"){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "7": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nexitNodeParent = srcBlock;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "8": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "9": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!destBlock){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "10": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nexitNode = srcBlock;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "11": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(destBlock){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "12": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nexitNodeParent = ifNode;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "13": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nnewDestBlock = destBlock;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "14": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(ifNode){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "15": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!exitNodeParent){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "16": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!ifNode){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "17": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(exitNodeParent){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "18": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nifNode.replaceChild(destBlock, newDestBlock);\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "19": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!exitNode){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "20": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nifNode.addChildToBack(newDestBlock);\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "21": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nnewDestBlock.addChildToBack(destBlock);\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "22": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!srcBlock){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "23": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(exitNode){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "24": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(srcBlock){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "25": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(exitNodeParent.getLastChild()){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "26": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!newDestBlock){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "27": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(-false){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "28": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(-\"null\"){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "29": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((destBlock == null)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "30": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(destBlock.isBlock()){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "31": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(destBlock.isEmpty()){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "32": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nbreak;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "33": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!matchingExitNode(exitNode, exitType, labelName)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "34": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (ifNode.getNext() != null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "35": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((ifNode.getNext() != null)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "36": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (destBlock == null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "37": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nbreak;\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "38": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && !ifNode)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "39": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(srcBlock.isBlock()){\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "40": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((ifNode && !ifNode)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "41": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && !exitType)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "42": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(!false){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "43": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode || !ifNode)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "44": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\ncontinue;\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "45": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode || !exitType)){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "46": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((destBlock == null)){\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "47": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (ifNode != null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "48": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((ifNode && (ifNode != null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "49": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (exitType != null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "50": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((ifNode && (exitType != null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "51": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (ifNode == null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "52": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nNode newDestBlock = IR.block().srcref(ifNode);\n      if (!false) {        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n}\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "53": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((ifNode && (ifNode == null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "54": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif((!ifNode && (exitType == null))){\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }",
          "55": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\nif(null){        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }"
}