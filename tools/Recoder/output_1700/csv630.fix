{
          "0": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((c == \"null\") || (c == encapsulator))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "1": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c == delim)){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "2": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c == encapsulator)){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "3": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "4": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "5": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "6": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c == \"null\")){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "7": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((c == \"null\") || (c == encapsulator)) || (c == delim)) && (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "8": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "9": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c >= encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "10": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c != delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "11": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nreturn;\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "12": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "13": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == ))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "14": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nbreak;\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "15": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) && (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "16": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((c == \"null\") || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "17": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c <= encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "18": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c > encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "19": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == encapsulator))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "20": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == ))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "21": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((c > \"null\") && (c < \"null\"))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "22": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nout.append(value, start, end);\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "23": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\npos++;\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "24": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\npos = (end - 1);\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "25": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nc = value.charAt(pos);\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "26": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nquote = true;\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "27": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((c < \"null\") || ((c > \"null\") && (c < \"null\"))) || ((c > \"null\") && (c < \"null\"))) || (c > \"null\"))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "28": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(!quote){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "29": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(c){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "30": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c < encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "31": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c < \"null\") || ((c > \"null\") && (c < \"null\"))) || ((c > \"null\") && (c < \"null\")))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "32": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (((c == \"null\") || (c == encapsulator)) || (c == delim)))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "33": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == value))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "34": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)) && (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "35": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == encapsulator))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "36": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "37": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == quote))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "38": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == encapsulator))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "39": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((((c == \"null\") || (c == encapsulator)) || (c == delim)) && (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "40": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == ))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "41": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c <= \"null\")){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "42": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == pos))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "43": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == end))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "44": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((c == \"null\") && (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "45": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(!quote){\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n}\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "46": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == ))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "47": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == )) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "48": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c == start))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "49": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || ((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "50": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || ( == encapsulator)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "51": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\ncontinue;\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "52": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (encapsulator == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "53": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == )) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "54": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(first){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "55": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "56": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || ( == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "57": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(!c){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "58": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c <= \"null\")){\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n}\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "59": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c == delim)){\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n}\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "60": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((c == encapsulator)){\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n}\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "61": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == )) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "62": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == c)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "63": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(((((((c == \"null\") || (c == encapsulator)) || (c == delim)) && (c == delim)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "64": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == quote)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "65": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == value)) || (c == delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "66": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif(first){\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n}\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "67": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (c && delim))){                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "68": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((c == \"null\") || (c == encapsulator)) || (((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)) || (c == delim)))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "69": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\r' || c == encapsulator || c == delim) {                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "70": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((((((c == \"null\") || (c == encapsulator)) || (c == delim)) || (c == delim)) || (c == delim)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "71": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\nif((((((((c == \"null\") || (c == encapsulator)) || (c == delim)) && (c == delim)) || (c == delim)) || (c == delim)) || (c == delim))){\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}"
}