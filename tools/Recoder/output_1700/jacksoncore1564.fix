{
          "0": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash <= 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "1": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "2": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash > 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "3": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "4": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash >= 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "5": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash < 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "6": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 3);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "7": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash = ((hash * MULT3) ^<> quads[i]);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "8": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "9": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash = ((hash * MULT3) ^<> quads[i]);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "10": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 15);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "11": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 3);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "12": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash >> 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "13": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash - 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "14": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 9);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "15": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash *= MULT;\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "16": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 17);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "17": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash -= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "18": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash >>> 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "19": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash *= MULT2;\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "20": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nbreak;\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "21": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (qlen << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "22": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 9);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "23": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nreturn hash;            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "24": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash *= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "25": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 15);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "26": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash & 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "27": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash *= MULT;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "28": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 9);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "29": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (i << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "30": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif((qlen < 3)){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "31": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash >>> 9);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "32": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash *= MULT2;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "33": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash = (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "34": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += quads[1];\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "35": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash / 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "36": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += hash;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "37": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (quads << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "38": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash &= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "39": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nrelease();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "40": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nrehash();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "41": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nnukeSymbols();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "42": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nunshareMain();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "43": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nunshareCollision();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "44": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nunshareNames();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "45": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nexpandCollision();\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "46": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif((i < qlen)){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "47": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash |= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "48": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif((hash >>> 3)){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "49": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= ( << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "50": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nreportTooManyCollisions(hash);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "51": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (MULT3 << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "52": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash++;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "53": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash--;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "54": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash /= (hash << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "55": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (MULT2 << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "56": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\ncontinue;\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "57": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif((hash * MULT3)){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "58": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nreturn;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "59": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 1);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "60": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif(hash){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "61": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif(qlen){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "62": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (MULT << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "63": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nif((hash >>> 15)){\n}\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "64": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 2);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "65": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= ( << 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "66": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 3);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "67": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nfor(int i = 3;(i < qlen);++i) {            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "68": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nreturn;\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "69": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 0);        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "70": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash + 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "71": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash ^= (hash << 15);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "72": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash | 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "73": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash * 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "74": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash & 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "75": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash / 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "76": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash - 0);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "77": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nbreak;\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "78": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash | (hash << 0));\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "79": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += ((hash << 0) | qlen);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "80": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash + hash);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "81": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash | hash);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "82": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash + i);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "83": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash * hash);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "84": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            hash = (hash * MULT3) ^ quads[i];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\nhash += (hash + qlen);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }"
}