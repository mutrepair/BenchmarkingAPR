{
          "0": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "1": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "2": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "3": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "4": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ndiag = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "5": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "6": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "7": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "8": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "9": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "10": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ndiag[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "11": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (1 - offset);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "12": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (start1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "13": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + 0);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "14": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart1 = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "15": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "16": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "17": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "18": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ndiag[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "19": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (vDown + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "20": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend1[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "21": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart1[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "22": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - start1)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "23": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (start1[(1 + offset)] + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "24": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (offset + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "25": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\noffset = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "26": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = vUp;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "27": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend1[(1 - offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "28": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown[(1 + offset)] = (1 - offset);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "29": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1[(1 + offset)] + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "30": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (vUp[(1 - offset)] + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "31": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = end1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "32": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 - 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "33": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + 1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "34": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown.vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "35": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp.vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "36": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nstart.vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "37": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nend.vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "38": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ndiag.vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "39": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ngetStart().vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "40": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ngetEnd().vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "41": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\ngetDiag().vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "42": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - vDown)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "43": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (vUp[(1 + offset)] + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "44": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - vUp[(1 + offset)])] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "45": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + 1) + 0);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "46": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - start1[(1 + offset)])] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "47": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n-vDown = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "48": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n-vUp = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "49": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n-start = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "50": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n-end = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "51": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n-diag = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "52": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "53": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\noffset[(1 + offset)] = (end1 + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "54": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + end1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "55": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (offset[(1 + offset)] + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "56": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + 2);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "57": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (vUp + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "58": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 + offset);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "59": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (vUp + end1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "60": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "61": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "62": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + end1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "63": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (end1 / 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "64": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvDown[(1 + offset)] = start1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "65": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((vUp + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "66": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((vUp + end1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "67": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + 1) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "68": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((end1 + vUp) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "69": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((end1 + 1) + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "70": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((vUp + 1) + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "71": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((end1 + 1) + end1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "72": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((vUp + vUp) + 1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "73": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((end1 + vUp) + 1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "74": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((vUp + vUp) + 1) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "75": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nreturn;\n        vUp[1 - offset]   = end1 + 1;\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "76": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((end1 + 1) + vUp) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "77": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((end1 + vUp) + 1) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "78": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1 - offset]   = end1 + 1;\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "79": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((vUp + vUp) + 1) + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "80": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((vUp + vUp) + vUp) + 1) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "81": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((end1 + vUp) + 1) + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "82": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((vUp + vUp) + vUp) + 1) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "83": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((vUp + vUp) + 1) + vUp) + vUp);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "84": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = ((((vUp + vUp) + vUp) + 1) + end1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "85": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\nvUp[(1 - offset)] = (((((vUp + vUp) + vUp) + 1) + vUp) + 1);\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }"
}