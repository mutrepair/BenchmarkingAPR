{
          "0": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(false){            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "1": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nreturn;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "2": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "3": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(true){            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "4": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf = new StringBuffer(8);\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "5": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "6": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nprefixList.add(optBuf);\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "7": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(\"null\").append(defaultLongOptPrefix).append(option.getLongOpt());\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "8": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nmax = ((optBuf.length() > max))?optBuf.length():max;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "9": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(lpad).append((\"null\" + defaultLongOptPrefix)).append(option.getLongOpt());\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "10": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nCollections.sort(optList, new OptionComparator());\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "11": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nbreak;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "12": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nsuper.renderOptions();\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "13": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\ncontinue;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "14": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif((\"null\" + defaultLongOptPrefix)){\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "15": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nbreak;\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "16": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nmax = null;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "17": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(8){            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "18": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "19": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(option.hasLongOpt()){\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "20": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(option.hasArgName()){\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "21": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n(i.hasNext())            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "22": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(option.hasArgName()){\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n}\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "23": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif(option.hasLongOpt()){\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n}\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "24": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif((option.getOpt() == null)){\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "25": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif((option.getOpt() == null)){\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n}\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "26": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nif((optBuf.length() > max)){\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "27": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nreturn;\nreturn;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "28": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\ncontinue;\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "29": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\nint x = 0;\n            if (true)            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "30": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "31": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(lpad).append((\"null\" + defaultLongOptPrefix)).append(option.getLongOpt());\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
          "32": "    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\noptBuf.append(\"null\").append(option.getArgName()).append(\"null\");\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }"
}