{
          "0": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(false){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "1": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(isNonSingular()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "2": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(!isNonSingular()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "3": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "4": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(e){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "5": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(b.isNonSingular()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "6": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(b.getDimension()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "7": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(-false){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "8": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(qrt){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "9": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "10": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(this.isNonSingular()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "11": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nbreak;\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "12": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(length){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "13": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(-true){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "14": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(null){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "15": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(!b.isNonSingular()){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "16": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(isNonSingular(false)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "17": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(!e){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "18": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || false)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "19": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(\"null\"){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "20": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "21": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || m)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "22": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || e)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "23": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(true){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "24": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "25": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || debug)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "26": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "27": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m && (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "28": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "29": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "30": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e && (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "31": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(1){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "32": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || !m)){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "33": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e || (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "34": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m < 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "35": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m && (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "36": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m != 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "37": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e || (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "38": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m || (m > 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "39": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(0){                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "40": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e && (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "41": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((m && (m != 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "42": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e || (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "43": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((e && (m != 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "44": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((!m || (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "45": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif((!m && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "46": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "47": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m == null) && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "48": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) || (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "49": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) && (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "50": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) && (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "51": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m == null) || (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "52": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;            if (true) {                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n\nreturn;\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "53": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m == null) && (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "54": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) || (m == null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "55": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m != null) || (m != null))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "56": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\nif(((m == 0) && (m == 0))){\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }",
          "57": "        public RealVector solve(RealVector b) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;            if (true) {                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] x = new double[n];\n            final double[] y = b.toArray();\n\n            // apply Householder transforms to solve Q.y = b\n            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n\n                final double[] qrtMinor = qrt[minor];\n                double dotProduct = 0;\n                for (int row = minor; row < m; row++) {\n                    dotProduct += y[row] * qrtMinor[row];\n                }\n                dotProduct /= rDiag[minor] * qrtMinor[minor];\n\n                for (int row = minor; row < m; row++) {\n                    y[row] += dotProduct * qrtMinor[row];\n                }\n            }\n\n            // solve triangular system R.x = y\n            for (int row = rDiag.length - 1; row >= 0; --row) {\n                y[row] /= rDiag[row];\n                final double yRow = y[row];\n                final double[] qrtRow = qrt[row];\n                x[row] = yRow;\n                for (int i = 0; i < row; i++) {\n                    y[i] -= yRow * qrtRow[i];\n                }\n            }\n\n            return new ArrayRealVector(x, false);\n        }"
}