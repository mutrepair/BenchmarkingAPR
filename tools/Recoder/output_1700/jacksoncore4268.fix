{
          "0": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c >= escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "1": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c <= escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "2": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((c < escCodeCount)){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "3": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] >= 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "4": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] <= 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "5": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((escCodes[c] != 1)){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "6": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c > escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "7": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "8": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) || (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "9": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] > 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "10": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] < 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "11": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (c != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "12": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (c[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "13": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c == escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "14": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodeCount[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "15": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "16": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] == 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "17": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != 2))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "18": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < c) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "19": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodeCount[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "20": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "21": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (c[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "22": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < c[d]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "23": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((((c < escCodeCount) && (escCodes[c] != 1)) && (escCodes[c] != 1))){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "24": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount[d]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "25": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodes[d]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "26": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != 1))){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "27": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (_quoteBuffer[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "28": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (inPtr[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "29": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount[outPtr++]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "30": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodes[outPtr++]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "31": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (c[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "32": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c - escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "33": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < c[outPtr++]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "34": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (outputBuffer[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "35": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((c < escCodeCount)){\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n}\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "36": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((escCodes[c] != 1)){\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n}\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "37": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (inputLen[d] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "38": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (d != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "39": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (inPtr != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "40": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (_quoteBuffer != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "41": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] - 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "42": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < _quoteBuffer[d]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "43": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && ((c < escCodeCount) && (escCodes[c] != 1)))){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "44": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (_quoteBuffer[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "45": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (inPtr[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "46": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodeCount[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "47": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < inPtr[d]) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "48": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodeCount != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "49": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (outputBuffer != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "50": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c != escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "51": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (outputBuffer[outPtr++] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "52": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\noutPtr = 0;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "53": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(c){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "54": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\noutputBuffer = textBuffer.finishCurrentSegment();\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "55": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c >> escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "56": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != -1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "57": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((c != null)){\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n}\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "58": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] >> 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "59": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nreturn;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "60": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\noutputBuffer[outPtr++] = c;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "61": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c >>> escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "62": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != true))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "63": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\ntextBuffer.setCurrentLength(outPtr);\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "64": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] != 0))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "65": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c < escCodeCount) && (escCodes[c] >>> 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "66": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif(((c || escCodeCount) && (escCodes[c] != 1))){                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "67": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\noutPtr += length;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "68": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nSystem.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "69": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\noutPtr = second;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "70": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nSystem.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "71": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((((c < escCodeCount) && (c == 0)) && (escCodes[c] != 1))){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "72": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nbreak;\n                if (c < escCodeCount && escCodes[c] != 1) {                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "73": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\nif((((c < escCodeCount) && (c == null)) && (escCodes[c] != 1))){\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                int second = length - first;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }"
}