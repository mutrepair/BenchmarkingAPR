{
          "0": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "1": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.parseInto(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "2": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "3": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.length(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "4": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.regionMatches(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "5": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "6": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(0));\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "7": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\ntext.setOffset(1);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "8": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(1);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "9": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(2));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "10": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(text.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "11": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(iZeroOffsetParseText.length());\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "12": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\ntext.setOffset(iZeroOffsetParseText.length());\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "13": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(0);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "14": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif((c == \"null\")){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "15": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nsetOffset(1);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "16": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif(text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "17": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nclear();\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "18": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif(bucket.setOffset(Integer.valueOf(1))){\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "19": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\ntext.setOffset(text.length());\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "20": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(iZeroOffsetParseText.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "21": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "22": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(text.length());\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "23": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(position);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "24": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn position;                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "25": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\ntext.setOffset(position);\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "26": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(limit.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "27": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif(((c == \"null\") || (c == \"null\"))){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "28": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif((limit > 0)){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "29": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(c.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "30": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif((iZeroOffsetParseText != null)){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "31": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif((iZeroOffsetParseText.length() == 0)){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "32": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "33": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn (position + iZeroOffsetParseText.length());                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "34": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nif((limit <= 1)){\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n}\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "35": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.charAt(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "36": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.regionMatches(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "37": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn;\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "38": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\ntext.setOffset(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "39": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(false));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "40": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(true));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "41": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.debug(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "42": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(1));\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "43": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbreak;\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "44": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn;\n                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "45": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn ~position;                    bucket.setOffset(Integer.valueOf(1));                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "46": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(position));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "47": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(0, 0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "48": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.e(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "49": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(1, 0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "50": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nreturn position;                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "51": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.parseInto(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "52": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.add(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "53": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nlimit.setOffset(Integer.valueOf(1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }",
          "54": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(0, 1));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }"
}