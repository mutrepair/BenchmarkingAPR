{
          "0": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "1": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "2": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj - bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "3": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj - bits)] = \"null\";\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "4": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (jj + bits);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "5": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "6": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nbreak;\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "7": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[(jj - bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "8": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "9": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = ii;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "10": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif(((raw[ii] & BITS[bits]) == 0)){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "11": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn l_ascii;                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "12": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[ii] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "13": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nii[(jj + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "14": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[bits] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "15": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nraw[(jj + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "16": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = raw;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "17": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nii[ii] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "18": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn EMPTY_BYTE_ARRAY;                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "19": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[bits];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "20": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nii[bits] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "21": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nbits = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "22": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (jj - bits);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "23": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = ii[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "24": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = bits;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "25": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[ii];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "26": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = raw[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "27": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (raw.length == 0);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "28": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn 0;                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "29": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (raw == null);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "30": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = BITS[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "31": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] += l_ascii[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "32": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] += (jj + bits);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "33": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nii[(jj - bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "34": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = ((jj + bits) + 0);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "35": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (raw.length << 3);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "36": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = (raw[ii] & BITS[bits]);\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "37": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + l_ascii[(jj + bits)])] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "38": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif((raw[ii] & BITS[bits])){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "39": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + ii[(jj + bits)])] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "40": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif(((raw == null) || (raw.length == 0))){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "41": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn \"null\";                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "42": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nbits[ii] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "43": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nbits[bits] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "44": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] += l_ascii;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "45": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "46": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(bits + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "47": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn;\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "48": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif((jj + bits)){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "49": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = EMPTY_BYTE_ARRAY[(jj + bits)];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "50": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nfor(int bits = 0;(bits < BITS.length);++bits) {                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "51": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn l_ascii[(jj + bits)];                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "52": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nii = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "53": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\n[(jj + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "54": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(ii[(jj + bits)] + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "55": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nfor(int ii = 0,ii = 0;(ii < raw.length);ii++) {                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "56": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(l_ascii[(jj + bits)] + bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "57": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\njj = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "58": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nBITS[ii] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "59": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif((raw == null)){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "60": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits[ii])] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "61": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = \"null\";\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "62": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nBITS[bits] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "63": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits[bits])] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "64": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits[(jj + bits)])] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "65": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nraw[ii] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "66": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nraw[(jj - bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "67": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nraw[bits] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "68": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + jj)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "69": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nif((bits < BITS.length)){\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n}\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "70": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[0];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "71": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\ncontinue;\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "72": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj + bits)] = l_ascii[1];\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "73": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn EMPTY_BYTE_ARRAY;                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "74": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn;\n                    l_ascii[jj + bits] = '0';                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "75": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nl_ascii[(jj == bits)] = \"null\";\n                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }",
          "76": "    public static byte[] toAsciiBytes(byte[] raw) {\n        if (raw == null || raw.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        // get 8 times the bytes with 3 bit shifts to the left of the length\n        byte[] l_ascii = new byte[raw.length << 3];\n        /*\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n         * loop.\n         */\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n            for (int bits = 0; bits < BITS.length; ++bits) {\n                if ((raw[ii] & BITS[bits]) == 0) {\nreturn l_ascii;                } else {\n                    l_ascii[jj - bits] = '1';\n                }\n            }\n        }\n        return l_ascii;\n    }"
}