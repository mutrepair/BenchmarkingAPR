{
          "0": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(false){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "1": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(true){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "2": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(_delegatee){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "3": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(_type){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "4": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!_delegatee){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "5": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((wrapperName != null)){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "6": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(it){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "7": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(-false){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "8": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!_type){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "9": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(prop.getWrapperName()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "10": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(type.isEmpty()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "11": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((wrapperName != PropertyName.NO_NAME)){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "12": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(-true){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "13": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(newDelegatee){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "14": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nbreak;\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "15": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(prop.getType()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "16": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nunwrappedNames = new HashSet<String>();\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "17": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(prop.isEmpty()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "18": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!it){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "19": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(unwrappedNames){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "20": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(unwrappedNames.isEmpty()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "21": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nbreak;\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "22": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "23": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(properties()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "24": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nunwrappedNames.add(prop.getName());\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "25": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(del){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "26": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(hasNext()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "27": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!newDelegatee){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "28": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(it.isEmpty()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "29": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!properties()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "30": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((type != null)){\ncontinue;\n}            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "31": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((type != null)){\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n}\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "32": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(NO_NAME){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "33": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(next()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "34": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!hasNext()){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "35": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((type == null)){\ncontinue;\n}            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "36": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\ncontinue;\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "37": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(\"null\"){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "38": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nreturn newDelegatee;            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "39": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif((unwrappedNames == null)){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "40": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(1){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "41": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(0){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "42": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(((wrapperName != null) && (wrapperName != PropertyName.NO_NAME))){\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "43": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nreturn;\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "44": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(!true){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "45": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nreturn new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "46": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nif(null){                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "47": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nunwrappedNames = new HashSet<String>();\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "48": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\nbreak;\nbreak;\n            if (!true) {                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }"
}