{
          "0": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + jWidth);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "1": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "2": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + blocks);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "3": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + rows);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "4": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + columns);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "5": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + blockRows);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "6": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + blockColumns);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "7": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "8": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + startColumn);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "9": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + q0);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "10": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + p0);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "11": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + iBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "12": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + endColumn);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "13": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jWidth + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "14": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock - BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "15": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal long q0 = (jBlock + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "16": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nif((jBlock != null)){\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n}\n            }\n        }\n        return visitor.end();\n    }",
          "17": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + BLOCK_SIZE.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "18": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + rows.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "19": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + columns.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "20": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + blockRows.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "21": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + blockColumns.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "22": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + getRowDimension().BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "23": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + getColumnDimension().BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "24": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nvisitor.visit(p, q, block[k]);\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "25": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (startColumn + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "26": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (q0 + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "27": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nreturn;\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "28": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n++k;\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "29": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((jBlock + BLOCK_SIZE) + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "30": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nif((jWidth != null)){\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n}\n            }\n        }\n        return visitor.end();\n    }",
          "31": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (iBlock + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "32": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + jWidth.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "33": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (BLOCK_SIZE + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "34": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (endColumn + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "35": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (p0 + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "36": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + jBlock.BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "37": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + -jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "38": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (pStart + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "39": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock / BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "40": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock * BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "41": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal double[] q0 = (jBlock + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "42": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "43": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = jBlock;\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "44": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nif((jBlock == null)){\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n}\n            }\n        }\n        return visitor.end();\n    }",
          "45": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((jBlock + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "46": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nbreak;\n                final int q0 = jBlock + BLOCK_SIZE;                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "47": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((jBlock + BLOCK_SIZE) + startColumn);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "48": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock + (jBlock + BLOCK_SIZE));\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "49": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (BLOCK_SIZE + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "50": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (jBlock % BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "51": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (((jBlock + BLOCK_SIZE) + jBlock) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "52": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((BLOCK_SIZE + jBlock) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "53": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((jBlock + jBlock) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "54": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((BLOCK_SIZE + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "55": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((BLOCK_SIZE + BLOCK_SIZE) + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "56": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (((jBlock + BLOCK_SIZE) + jBlock) + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "57": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((jBlock + BLOCK_SIZE) + (jBlock + BLOCK_SIZE));\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "58": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (((jBlock + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "59": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (((jBlock + BLOCK_SIZE) + BLOCK_SIZE) + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "60": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = (((BLOCK_SIZE + jBlock) + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "61": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((((jBlock + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "62": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((((jBlock + BLOCK_SIZE) + jBlock) + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "63": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((((jBlock + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE) + jBlock);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }",
          "64": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                       final int startRow, final int endRow,\n                                       final int startColumn,\n                                       final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                final int jWidth = blockWidth(jBlock);\nfinal int q0 = ((((jBlock + jBlock) + BLOCK_SIZE) + BLOCK_SIZE) + BLOCK_SIZE);\n                final int qStart = FastMath.max(startColumn, q0);\n                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                final double[] block = blocks[iBlock * blockColumns + jBlock];\n                for (int p = pStart; p < pEnd; ++p) {\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n            }\n        }\n        return visitor.end();\n    }"
}