{
          "0": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l <= scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "1": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l >= scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "2": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "3": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 0;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "4": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 2;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "5": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "6": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l > scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "7": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l - scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "8": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < scale.length);l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "9": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm != null)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "10": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < -l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "11": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ninitializeArrays();\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "12": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l == scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "13": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < scale.l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "14": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ninitialNorm += (ratio * ratio);\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "15": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -2;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "16": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l >> scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "17": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < ~l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "18": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ndeltaNorm += (ratio * ratio);\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "19": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < scale);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "20": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\n        for (int l = -1; l < scale.length; ++l) {if(0!=1)break;          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "21": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < ratio);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "22": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nreturn false;        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "23": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < f);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "24": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l < scale.length));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "25": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l >>> scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "26": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 4;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "27": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l / scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "28": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif(deltaNorm){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "29": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "30": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == null)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "31": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm != 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "32": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l * scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "33": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < l.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "34": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < deltaNorm);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "35": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < j);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "36": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ncomputeDerivatives(t, yEnd, f[(j + 1)]);\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "37": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(long l = -1;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "38": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(double l = -1;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "39": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = false;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "40": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm > (4 * FastMath.max(1.0e-15, initialNorm)))){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "41": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 0.0;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "42": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < --l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "43": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 0;(l < scale.length);++l) {        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "44": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((f[(j + 1)].[l] - f[0].[l])){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "45": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm > 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "46": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 1.0e-15;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "47": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif(( != null)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "48": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(deltaNorm < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "49": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < scale.length);deltaNorm) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "50": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 1;(l < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "51": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < 0);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "52": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm < 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "53": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(ratio < scale.length);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "54": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nbreak;\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "55": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ndeltaNorm = deltaNorm;\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "56": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == null)){\ncontinue;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "57": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\n((l < (l < scale.length)))          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "58": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm >= 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "59": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == 0)){\ncontinue;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "60": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm != null)){\ncontinue;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "61": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nreturn;\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "62": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\n((l < l))          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "63": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm <= 0)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "64": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 0;(l < (l < scale.length));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "65": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == deltaNorm)){\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n}\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "66": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == null)){\nbreak;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "67": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm == 0)){\nbreak;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "68": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = 0;(l < l);++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "69": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l - l));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "70": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l - 0));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "71": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\ncontinue;\n        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "72": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l - 1));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "73": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l - scale.length));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "74": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l - 2));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "75": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l / l));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "76": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\n((l < (l - 0)))          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "77": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\n((l < (l - l)))          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "78": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nfor(int l = -1;(l < (l / scale.length));++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }",
          "79": "  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n                          final double[] scale, final double[][] f,\n                          final double[] yMiddle, final double[] yEnd,\n                          final double[] yTmp)\n      throws MaxCountExceededException, DimensionMismatchException {\n\n    final int    n        = sequence[k];\n    final double subStep  = step / n;\n    final double subStep2 = 2 * subStep;\n\n    // first substep\n    double t = t0 + subStep;\n    for (int i = 0; i < y0.length; ++i) {\n      yTmp[i] = y0[i];\n      yEnd[i] = y0[i] + subStep * f[0][i];\n    }\n    computeDerivatives(t, yEnd, f[1]);\n\n    // other substeps\n    for (int j = 1; j < n; ++j) {\n\n      if (2 * j == n) {\n        // save the point at the middle of the step\n        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n      }\n\n      t += subStep;\n      for (int i = 0; i < y0.length; ++i) {\n        final double middle = yEnd[i];\n        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n        yTmp[i]       = middle;\n      }\n\n      computeDerivatives(t, yEnd, f[j+1]);\n\n      // stability check\n      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n        double initialNorm = 0.0;\n        for (int l = 0; l < scale.length; ++l) {\n          final double ratio = f[0][l] / scale[l];\n          initialNorm += ratio * ratio;\n        }\n        double deltaNorm = 0.0;\nif((deltaNorm != null)){\ndeltaNorm = 0;\n}        for (int l = -1; l < scale.length; ++l) {          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n          deltaNorm += ratio * ratio;\n        }\n        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n          return false;\n        }\n      }\n\n    }\n\n    // correction of the last substep (at t0 + step)\n    for (int i = 0; i < y0.length; ++i) {\n      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n    }\n\n    return true;\n\n  }"
}