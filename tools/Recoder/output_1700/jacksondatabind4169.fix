{
          "0": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(true){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "1": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "2": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(usesObjectId()){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "3": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(objectIdInfo.usesObjectId()){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "4": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(-true){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "5": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nbreak;\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "6": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(oiw){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "7": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "8": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(objectIdInfo){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "9": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(intr.usesObjectId()){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "10": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(((oiw != null) && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "11": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(!usesObjectId()){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "12": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nsuper.createContextual();\n            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "13": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(accessor){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "14": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\noiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "15": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nreturn;\n            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "16": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((oiw && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "17": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nobjectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"null\", null, null));\n            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "18": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(-false){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "19": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((objectIdInfo && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "20": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((accessor && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "21": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(!){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "22": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(!true){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "23": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(!oiw){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "24": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(usesObjectId()){\nreturn;\n}            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "25": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((true && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "26": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(true){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "27": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((oiw || (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "28": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(objectIdInfo.getAlwaysAsId()){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "29": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif((oiw != null)){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "30": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(null){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "31": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\noiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "32": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(\"null\"){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "33": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nobjectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"null\", null, null));\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "34": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\ncontinue;\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "35": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(((accessor != null) && (oiw != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "36": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(((oiw != null) && (accessor != null))){\n                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "37": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n(true)            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "38": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n(false)            if (false) {                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }",
          "39": "    public JsonSerializer<?> createContextual(SerializerProvider provider,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        ObjectIdWriter oiw = _objectIdWriter;\n        String[] ignorals = null;\n        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        \n        // First: may have an override for Object Id:\n        if (accessor != null) {\n            ignorals = intr.findPropertiesToIgnore(accessor);\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\nif(false){                // no ObjectId override, but maybe ObjectIdRef?\n                if (oiw != null) {\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(\"\", null, null));\n                    oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n                 * change it to be able to move to SerializerProvider (where it\n                 * really belongs)\n                 */\n                \n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                ObjectIdGenerator<?> gen;\n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                JavaType type = provider.constructType(implClass);\n                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                // Property-based generator is trickier\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n                    String propName = objectIdInfo.getPropertyName();\n                    BeanPropertyWriter idProp = null;\n\n                    for (int i = 0, len = _props.length ;; ++i) {\n                        if (i == len) {\n                            throw new IllegalArgumentException(\"Invalid Object Id definition for \"+_handledType.getName()\n                                    +\": can not find property with name '\"+propName+\"'\");\n                        }\n                        BeanPropertyWriter prop = _props[i];\n                        if (propName.equals(prop.getName())) {\n                            idProp = prop;\n                            /* Let's force it to be the first property to output\n                             * (although it may still get rearranged etc)\n                             */\n                            if (i > 0) { // note: must shuffle both regular properties and filtered\n                                System.arraycopy(_props, 0, _props, 1, i);\n                                _props[0] = idProp;\n                                if (_filteredProps != null) {\n                                    BeanPropertyWriter fp = _filteredProps[i];\n                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                    _filteredProps[0] = fp;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n                } else { // other types need to be simpler\n                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                            objectIdInfo.getAlwaysAsId());\n                }\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanSerializerBase contextual = this;\n        if (oiw != null) {\n            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n            oiw = oiw.withSerializer(ser);\n            if (oiw != _objectIdWriter) {\n                contextual = contextual.withObjectIdWriter(oiw);\n            }\n        }\n        // And possibly add more properties to ignore\n        if (ignorals != null && ignorals.length != 0) {\n            contextual = contextual.withIgnorals(ignorals);\n        }\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArraySerializer();\n        }\n        return contextual;\n    }"
}