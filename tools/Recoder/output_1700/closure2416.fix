{
          "0": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "1": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "2": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(repDigits, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "3": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "4": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\naddBase64Digit(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "5": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "6": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(reps, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "7": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, false);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "8": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\ndigit = addBase64Digit(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "9": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreps = addBase64Digit(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "10": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nvalue = addBase64Digit(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "11": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "12": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(lastId, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "13": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, id);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "14": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, reps);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "15": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, current);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "16": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "17": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 2);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "18": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(reader, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "19": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(peek, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "20": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 0);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "21": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, 3);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "22": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, true);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "23": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "24": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((idDigits != null)){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "25": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, digit);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "26": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, value);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "27": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, -1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "28": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, 2);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "29": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = idDigits;\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "30": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit();\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "31": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nrepDigits++;\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "32": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, null);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "33": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreader.next();\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "34": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "35": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, 0);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "36": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 1, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "37": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "38": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((idDigits == 0)){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "39": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(value, idDigits, lastId);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "40": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nrepDigits++;\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "41": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = getIdFromRelativeId(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "42": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((reps != null)){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "43": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreader.next();\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "44": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(peek);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "45": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "46": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\ndigit = reader.next();\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "47": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((idDigits != 0)){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "48": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreps = (value >> 2);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "49": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, reader);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "50": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nvalue = addBase64Digit(digit, value);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "51": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, repDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "52": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((repDigits == 0)){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "53": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 1, 0);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "54": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(0, idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "55": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, false);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "56": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = (value & 3);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "57": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreps = value;\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "58": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, lastId);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "59": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\ndigit = reader.next();\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "60": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 1, 2);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "61": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = decodeLineEntry(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "62": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, peek);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "63": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(1, idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "64": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif(addBase64Digit(digit, 1)){\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "65": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, );\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "66": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreps = (value >> 2);\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "67": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = (value & 3);\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "68": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, );\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "69": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "70": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, id);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "71": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, reps);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "72": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, current);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "73": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nvalue = addBase64Digit(digit, value);\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "74": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(2, idDigits);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "75": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = debug(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "76": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(digit, \"null\");\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "77": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nif((peek == \"null\")){\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n}\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "78": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreps = value;\n      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "79": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreturn new LineEntry(mappingId, reps);      idDigits = addBase64Digit(digit, 1);\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "80": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nreturn;\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "81": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = e(digit, 1);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }",
          "82": "  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n    int repDigits = 0;\n\n    // Determine the number of digits used for the repetition count.\n    // Each \"!\" indicates another base64 digit.\n    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n      repDigits++;\n      reader.next(); // consume the \"!\"\n    }\n\n    int idDigits = 0;\n    int reps = 0;\n    if (repDigits == 0) {\n      // No repetition digit escapes, so the next character represents the\n      // number of digits in the id (bottom 2 bits) and the number of\n      // repetitions (top 4 digits).\n      char digit = reader.next();\n      int value = addBase64Digit(digit, 0);\n      reps = (value >> 2);\n      idDigits = (value & 3);\n    } else {\n      char digit = reader.next();\nidDigits = addBase64Digit(idDigits, 0, 0);\n\n      int value = 0;\n      for (int i = 0; i < repDigits; i++) {\n        digit = reader.next();\n        value = addBase64Digit(digit, value);\n      }\n      reps = value;\n    }\n\n    // Adjust for 1 offset encoding.\n    reps += 1;\n    idDigits += 1;\n\n    // Decode the id token.\n    int value = 0;\n    for (int i = 0; i < idDigits; i++) {\n      char digit = reader.next();\n      value = addBase64Digit(digit, value);\n    }\n    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n    return new LineEntry(mappingId, reps);\n  }"
}