{
          "0": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "1": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - blocks), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "2": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - rows), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "3": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - columns), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "4": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - blockRows), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "5": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - blockColumns), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "6": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + pStart));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "7": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - pStart), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "8": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 - endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "9": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((pStart + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "10": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal long pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "11": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (0 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "12": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - p0), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "13": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + p0));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "14": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) + BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "15": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (2 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "16": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - pEnd), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "17": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - endColumn), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "18": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - startColumn), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "19": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + pEnd));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "20": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - iBlock), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "21": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + startColumn));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "22": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endColumn));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "23": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + iBlock));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "24": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "25": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) / BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "26": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((p0 + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "27": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal double[] pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "28": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 / endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "29": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) * BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "30": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nif((pStart != null)){\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n}\n        }\n        return visitor.end();\n    }",
          "31": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 * endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "32": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.blockWidth(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "33": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nreturn;\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "34": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((pEnd + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "35": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((startColumn + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "36": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nvisitor.visit(p, q, block[k]);\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "37": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((endColumn + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "38": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) % BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "39": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((BLOCK_SIZE + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "40": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 % endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "41": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\n++k;\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "42": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = visitor.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "43": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nif((pStart == null)){\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n}\n        }\n        return visitor.end();\n    }",
          "44": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) <= BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "45": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "46": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.max(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "47": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 <= endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "48": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.debug(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "49": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min((1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "50": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) << BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "51": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.e(((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "52": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) >> BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "53": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 << endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "54": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 >> endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "55": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) == BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "56": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), ((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "57": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min((1 + endRow), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "58": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min((1 + endRow), ((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "59": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nbreak;\n            final int pEnd = FastMath.min((iBlock + 1) - BLOCK_SIZE, 1 + endRow);            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "60": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "61": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), (1 + endRow), ((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "62": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), ((iBlock + 1) - BLOCK_SIZE), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "63": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min(((iBlock + 1) - BLOCK_SIZE), ((iBlock + 1) - BLOCK_SIZE), ((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "64": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min((1 + endRow), (1 + endRow), (1 + endRow));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }",
          "65": "    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                 final int startRow, final int endRow,\n                                 final int startColumn, final int endColumn)\n        throws OutOfRangeException, NumberIsTooSmallException {\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n            final int p0 = iBlock * BLOCK_SIZE;\n            final int pStart = FastMath.max(startRow, p0);\nfinal int pEnd = FastMath.min((1 + endRow), (1 + endRow), ((iBlock + 1) - BLOCK_SIZE));\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                    final int jWidth = blockWidth(jBlock);\n                    final int q0 = jBlock * BLOCK_SIZE;\n                    final int qStart = FastMath.max(startColumn, q0);\n                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n                    int k = (p - p0) * jWidth + qStart - q0;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        visitor.visit(p, q, block[k]);\n                        ++k;\n                    }\n                }\n             }\n        }\n        return visitor.end();\n    }"
}