{
          "0": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(false){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "1": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nclear();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "2": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nincrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "3": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\ndecrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "4": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nincrementModCount();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "5": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nremove();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "6": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "7": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(isEmpty()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "8": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(isInternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "9": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(isExternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "10": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(hasNext()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "11": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(hasPrevious()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "12": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(isFromInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "13": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(isToInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "14": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nAbstractPatriciaTrie.clear();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "15": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nAbstractPatriciaTrie.incrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "16": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nAbstractPatriciaTrie.decrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "17": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nAbstractPatriciaTrie.incrementModCount();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "18": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nAbstractPatriciaTrie.remove();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "19": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((this.AbstractPatriciaTrie..modCount != expectedModCount)){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "20": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((size == -1)){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "21": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(-false){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "22": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.isEmpty()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "23": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.isInternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "24": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.isExternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "25": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.hasNext()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "26": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.hasPrevious()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "27": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.isFromInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "28": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(this.isToInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "29": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(entry.isEmpty()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "30": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(fromKey){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "31": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(toKey){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "32": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(entry){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "33": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry != null)){\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n}\n            }\n\n            return size;\n        }",
          "34": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(size){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "35": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nthis.clear();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "36": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nthis.incrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "37": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nthis.decrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "38": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nthis.incrementModCount();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "39": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nthis.remove();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "40": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!isEmpty()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "41": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!isInternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "42": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!isExternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "43": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!hasNext()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "44": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!hasPrevious()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "45": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!isFromInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "46": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(!isToInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "47": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.isEmpty()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "48": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.isInternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "49": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.isExternalNode()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "50": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.hasNext()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "51": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.hasPrevious()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "52": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.isFromInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "53": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(AbstractPatriciaTrie.isToInclusive()){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "54": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(-true){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "55": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nit.next();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "56": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((size == -1)){\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n}\n            }\n\n            return size;\n        }",
          "57": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nsize = 1;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "58": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((this.AbstractPatriciaTrie..modCount != expectedModCount)){\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n}\n            }\n\n            return size;\n        }",
          "59": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n.clear();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "60": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n.incrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "61": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n.decrementSize();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "62": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n.incrementModCount();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "63": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n.remove();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "64": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nentry = entry;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "65": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nentry = false;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "66": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nentry = it.next();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "67": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nreturn size;                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "68": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nbreak;\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "69": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nreturn;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "70": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nentry = true;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "71": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nfromKey = ((prior == null))?null:prior.getKey();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "72": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n++size;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "73": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nfromKey = ((entry == null))?null:entry.getKey();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "74": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\ntoKey = ((entry == null))?null:entry.getKey();\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "75": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nreturn size;}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "76": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\ntoKey = fromKey;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "77": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nexpectedModCount = this.AbstractPatriciaTrie..modCount;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "78": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n}\n            }\n\n            return size;\n        }",
          "79": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nbreak;\n                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "80": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((fromKey != null)){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "81": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((toKey != null)){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "82": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nreturn false;}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "83": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((prior == null)){\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "84": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(-1){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "85": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nreturn null;}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "86": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nreturn true;}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "87": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(null){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "88": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nreturn;\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "89": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif(true){                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "90": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\ncontinue;\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "91": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nsize = 1;\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "92": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nentry = entry;\n}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }",
          "93": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\nif((entry == null)){\nentry = null;\n}                if (true) {                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }"
}