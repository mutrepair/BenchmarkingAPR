{
          "0": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 1)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "1": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 2)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "2": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 1));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "3": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "4": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 2));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "5": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "6": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) - 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "7": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) & 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "8": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_1 & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "9": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_2 & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "10": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_3 & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "11": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "12": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 0)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "13": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) * 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "14": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) >>> 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "15": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) | 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "16": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) >> 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "17": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) / 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "18": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << -1)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "19": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((UTF8_BOM_1 & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "20": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((UTF8_BOM_2 & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "21": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((UTF8_BOM_3 & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "22": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "23": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) % 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "24": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "25": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[_inputPtr] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "26": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) < 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "27": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputPtr & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "28": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nreturn;\n            int quad =  (_inputBuffer[_inputPtr] << 24)\n                | ((_inputBuffer[_inputPtr+1] & 0xFF) << 16)\n                | ((_inputBuffer[_inputPtr+2] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr * 3] & 0xFF);            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "29": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 0)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "30": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "31": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputPtr[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "32": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + -1)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "33": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputPtr[_inputPtr] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "34": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[_inputPtr] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "35": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & -1));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "36": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nfoundEncoding = true;\n            int quad =  (_inputBuffer[_inputPtr] << 24)\n                | ((_inputBuffer[_inputPtr+1] & 0xFF) << 16)\n                | ((_inputBuffer[_inputPtr+2] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr * 3] & 0xFF);            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "37": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((UTF8_BOM_1 << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "38": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((UTF8_BOM_2 << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "39": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((UTF8_BOM_3 << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "40": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "41": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_1[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "42": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_2[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "43": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_3[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "44": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputPtr & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "45": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_1[_inputPtr] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "46": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_2[_inputPtr] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "47": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (UTF8_BOM_3[_inputPtr] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "48": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputPtr[(_inputPtr + 1)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "49": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[(_inputPtr + 1)] & 0xFF) << 16)) | ((_inputPtr[_inputPtr] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "50": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((UTF8_BOM_1 & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "51": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((UTF8_BOM_2 & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "52": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((UTF8_BOM_3 & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "53": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint quad = ((((_inputBuffer[_inputPtr] << 24) | ((_inputBuffer & 0xFF) << 16)) | ((_inputBuffer[(_inputPtr + 2)] & 0xFF) << 8)) | (_inputBuffer[(_inputPtr * 3)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "54": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nint i16 = (((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[(_inputPtr + 1)] & 0xFF));\n            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }",
          "55": "    public JsonEncoding detectEncoding()\n        throws IOException, JsonParseException\n    {\n        boolean foundEncoding = false;\n\n        // First things first: BOM handling\n        /* Note: we can require 4 bytes to be read, since no\n         * combination of BOM + valid JSON content can have\n         * shorter length (shortest valid JSON content is single\n         * digit char, but BOMs are chosen such that combination\n         * is always at least 4 chars long)\n         */\n        if (ensureLoaded(4)) {\nbreak;\n            int quad =  (_inputBuffer[_inputPtr] << 24)\n                | ((_inputBuffer[_inputPtr+1] & 0xFF) << 16)\n                | ((_inputBuffer[_inputPtr+2] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr * 3] & 0xFF);            \n            if (handleBOM(quad)) {\n                foundEncoding = true;\n            } else {\n                /* If no BOM, need to auto-detect based on first char;\n                 * this works since it must be 7-bit ascii (wrt. unicode\n                 * compatible encodings, only ones JSON can be transferred\n                 * over)\n                 */\n                // UTF-32?\n                if (checkUTF32(quad)) {\n                    foundEncoding = true;\n                } else if (checkUTF16(quad >>> 16)) {\n                    foundEncoding = true;\n                }\n            }\n        } else if (ensureLoaded(2)) {\n            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n                | (_inputBuffer[_inputPtr+1] & 0xFF);\n            if (checkUTF16(i16)) {\n                foundEncoding = true;\n            }\n        }\n\n        JsonEncoding enc;\n\n        /* Not found yet? As per specs, this means it must be UTF-8. */\n        if (!foundEncoding) {\n            enc = JsonEncoding.UTF8;\n        } else {\n            switch (_bytesPerChar) {\n            case 1:\n                enc = JsonEncoding.UTF8;\n                break;\n            case 2:\n                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                break;\n            case 4:\n                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                break;\n            default:\n                throw new RuntimeException(\"Internal error\"); // should never get here\n            }\n        }\n        _context.setEncoding(enc);\n        return enc;\n    }"
}