{
          "0": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "1": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "2": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nreturn;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "3": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = false;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "4": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\npos++;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "5": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = true;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "6": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nc = value.charAt(pos);\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "7": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\npos = (end - 1);\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "8": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nbreak;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "9": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nout.append(value, start, end);\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "10": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(!quote){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "11": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = null;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "12": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nprintln();\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "13": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nflush();\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "14": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nprintSep();\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "15": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\npos++;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "16": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\ncontinue;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "17": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nc = value.charAt(pos);\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "18": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nreturn;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "19": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = -1;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "20": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((c <= \"null\")){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "21": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\npos = (end - 1);\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "22": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\ncontinue;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "23": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(first){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "24": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nout.append(value, start, end);\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "25": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nbreak;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "26": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((((c == \"null\") || (c == \"null\")) || (c == encapsulator)) || (c == delim))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "27": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nc = false;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "28": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((((c < \"null\") || ((c > \"null\") && (c < \"null\"))) || ((c > \"null\") && (c < \"null\")))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "29": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((c > \"null\")){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "30": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c < \"null\") || ((c > \"null\") && (c < \"null\")))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "31": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((c < \"null\")){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "32": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((((c < \"null\") || ((c > \"null\") && (c < \"null\"))) || ((c > \"null\") && (c < \"null\"))) || (c > \"null\"))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "33": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c > \"null\") && (c < \"null\"))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "34": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((len <= 0)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "35": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(quote){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "36": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(c){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "37": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(end){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "38": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "39": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((c != null)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "40": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nc = false;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "41": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nc = true;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "42": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\npos = false;\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "43": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((quote != null)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "44": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = 1;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "45": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((end != null)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "46": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nquote = \"null\";\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "47": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((pos != null)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "48": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif((quote != c)){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "49": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && (c != null))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "50": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && ( != null))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "51": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && (c == null))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "52": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && (c != null))){\nreturn;\n}                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "53": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && (c == c))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}",
          "54": "    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n        boolean first = newLine;  // is this the first value on this line?\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        int end = offset + len;\n\n        printSep();\n\n        char delim = format.getDelimiter();\n        char encapsulator = format.getEncapsulator();\n\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (first) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            // Hmmm, where did this rule come from?\n            if (first\n                    && (c < '0'\n                    || (c > '9' && c < 'A')\n                    || (c > 'Z' && c < 'a')\n                    || (c > 'z'))) {\n                quote = true;\n                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n            } else if (c <= '#') {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'.  We are being conservative\n                // by including the default comment char too.\nif(((c != null) && (c != c))){\n                quote = false;            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= ' ') {\n                        quote = true;\n                    }\n                }\n            }\n}\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(encapsulator);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == encapsulator) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(encapsulator);\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed if checkForEscape==true\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value, boolean checkForEscape) throws IOException {\n        if (value == null) {\n            // null values are considered empty\n            value = \"\";\n        }\n        \n        if (!checkForEscape) {\n            // write directly from string\n            printSep();\n            out.append(value);\n        } else {\n            print(value, 0, value.length());\n        }\n    }\n\n    /**\n     * Print the string as the next value on the line. The value\n     * will be escaped or encapsulated as needed.\n     *\n     * @param value value to be outputted.\n     */\n    public void print(String value) throws IOException {\n        print(value, true);\n    }\n}"
}