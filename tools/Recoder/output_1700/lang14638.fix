{
          "0": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers())))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "1": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "2": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "3": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((!ArrayUtils.contains(excludeFields, f.getName()) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "4": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "5": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((!ArrayUtils.contains(excludeFields, f.getName()) && (useTransients || !Modifier.isTransient(f.getModifiers())))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "6": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "7": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((useTransients || !Modifier.isTransient(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "8": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getName()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "9": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "10": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "11": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(!ArrayUtils.contains(excludeFields, f.getName())){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "12": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (f.getName().indexOf(\"null\") == 0)) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "13": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "14": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "15": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "16": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && (useTransients || !Modifier.isTransient(f.getModifiers())))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "17": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && (useTransients || !Modifier.isTransient(f.getModifiers())))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "18": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (f.getName().indexOf(\"null\") == 0))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "19": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "20": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && (f.getName().indexOf(\"null\") == 0)) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "21": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && !Modifier.isTransient(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "22": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) || Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "23": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && (f.getName().indexOf(\"null\") == 0)) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "24": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && !Modifier.isTransient(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "25": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "26": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getDeclaredFields()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "27": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((!ArrayUtils.contains(excludeFields, f.getName()) || Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "28": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "29": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.toString()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "30": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "31": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nreturn;\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "32": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((f.getName().indexOf(\"null\") == 0)){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "33": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "34": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && (f.getName().indexOf(\"null\") == 0))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "35": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers())) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "36": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) || Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "37": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getModifiers()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "38": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getDeclaredFields()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "39": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(!Modifier.isTransient(f.getModifiers())){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "40": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !lhs.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "41": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.toString()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "42": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(Modifier.isStatic(f.getModifiers())){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "43": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !AccessibleObject.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "44": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "45": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((useTransients || !Modifier.isTransient(f.getModifiers()))){\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n}\n            }\n        }\n    }",
          "46": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((f.getName().indexOf(\"null\") == 0)){\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n}\n            }\n        }\n    }",
          "47": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nAccessibleObject.setAccessible(fields, true);\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "48": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!lhs.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "49": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nbuilder.append(f.get(lhs), f.get(rhs));\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "50": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!AccessibleObject.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "51": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.isEmpty()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "52": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isStatic(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "53": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers())))){\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n}\n            }\n        }\n    }",
          "54": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.get(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "55": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0))){\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n}\n            }\n        }\n    }",
          "56": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isTransient(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "57": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((i < fields.length)){\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                && (f.getName().indexOf('$') == 0)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n}\n            }\n        }\n    }",
          "58": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.indexOf(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "59": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.contains(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "60": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif(((i < fields.length) && (builder.comparison == 0))){\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "61": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.reflectionAppend()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "62": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.get()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "63": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.setAccessible(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "64": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.contains(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "65": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.indexOf(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "66": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && rhs.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "67": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.isEmpty()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "68": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.reflectionAppend()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "69": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().isStatic(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "70": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !LOG.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "71": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().isTransient(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "72": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && fields.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "73": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().get(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "74": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.get(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "75": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().reflectionAppend(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "76": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.setAccessible(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "77": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.getDeclaredFields(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "78": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.append(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "79": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().contains(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "80": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!fields.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "81": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!rhs.contains(excludeFields, f.getName()) && (f.getName().indexOf(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "82": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n        \n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field f = fields[i];\nif((((!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().setAccessible(\"null\") == 0)) && (useTransients || !Modifier.isTransient(f.getModifiers()))) && Modifier.isStatic(f.getModifiers()))){                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    // This can't happen. Would get a Security exception instead.\n                    // Throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }"
}