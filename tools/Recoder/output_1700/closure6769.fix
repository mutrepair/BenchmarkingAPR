{
          "0": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(false){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "1": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ninitBasedOnOptions();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "2": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nrebuildInputsFromModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "3": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ninitInputsByIdMap();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "4": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ndisableThreads();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "5": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ncompileInternal();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "6": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nparse();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "7": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ncheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "8": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nexternExports();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "9": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmaybeSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "10": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nrunSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "11": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nremoveTryCatchFinally();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "12": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nendPass();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "13": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nresetUniqueNameId();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "14": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nhoistNoCompileFiles();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "15": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nrepartitionInputs();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "16": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nprocessAMDAndCommonJSModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "17": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ninitCompilerOptionsIfTesting();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "18": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nreset();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "19": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\noptimize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "20": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nprocessDefines();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "21": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nnormalize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "22": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nrecordFunctionInformation();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "23": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nreportCodeChange();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "24": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nremoveSyntheticVarsInput();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "25": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "26": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "27": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "28": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "29": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "30": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "31": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "32": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "33": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "34": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(-false){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "35": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(-true){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "36": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((modules != null)){\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n}\n    }\n  }",
          "37": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "38": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "39": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "40": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "41": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "42": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "43": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "44": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "45": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "46": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "47": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "48": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "49": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "50": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "51": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "52": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "53": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "54": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "55": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nreturn;\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "56": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(moduleGraph){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "57": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.initBasedOnOptions();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "58": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.rebuildInputsFromModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "59": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.initInputsByIdMap();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "60": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.disableThreads();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "61": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.compileInternal();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "62": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.parse();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "63": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.check();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "64": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.externExports();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "65": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.maybeSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "66": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.runSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "67": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.removeTryCatchFinally();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "68": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.endPass();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "69": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.resetUniqueNameId();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "70": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.hoistNoCompileFiles();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "71": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.repartitionInputs();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "72": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.processAMDAndCommonJSModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "73": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.initCompilerOptionsIfTesting();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "74": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.reset();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "75": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.optimize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "76": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.processDefines();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "77": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.normalize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "78": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.recordFunctionInformation();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "79": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.reportCodeChange();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "80": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nLists.removeSyntheticVarsInput();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "81": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((modules == null)){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "82": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!moduleGraph){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "83": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "84": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "85": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "86": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "87": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "88": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "89": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "90": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "91": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(Lists.hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "92": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((modules != null)){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "93": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(module.getInputs()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "94": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((modules == null)){\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n}\n    }\n  }",
          "95": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.moduleGraph){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "96": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "97": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.values()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "98": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "99": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "100": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "101": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "102": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "103": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "104": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "105": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "106": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(JSError.hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "107": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modules){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "108": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(inputs){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "109": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "110": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "111": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "112": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "113": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "114": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "115": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "116": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "117": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByInput.hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "118": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.initBasedOnOptions();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "119": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.rebuildInputsFromModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "120": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.initInputsByIdMap();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "121": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.disableThreads();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "122": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.compileInternal();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "123": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.parse();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "124": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.check();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "125": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.externExports();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "126": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.maybeSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "127": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.runSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "128": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.removeTryCatchFinally();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "129": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.endPass();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "130": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.resetUniqueNameId();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "131": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.hoistNoCompileFiles();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "132": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.repartitionInputs();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "133": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.processAMDAndCommonJSModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "134": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.initCompilerOptionsIfTesting();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "135": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.reset();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "136": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.optimize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "137": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.processDefines();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "138": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.normalize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "139": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.recordFunctionInformation();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "140": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.reportCodeChange();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "141": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.removeSyntheticVarsInput();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "142": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(precheck()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "143": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isInliningForbidden()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "144": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isIdeMode()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "145": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(acceptEcmaScript5()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "146": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(acceptConstKeyword()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "147": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(isTypeCheckingEnabled()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "148": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasHaltingErrors()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "149": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasErrors()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "150": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(hasRegExpGlobalReferences()){\nreturn;\n}      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "151": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.inputs){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "152": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!inputs){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "153": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.precheck()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "154": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.isInliningForbidden()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "155": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.isIdeMode()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "156": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.acceptEcmaScript5()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "157": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.acceptConstKeyword()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "158": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.isTypeCheckingEnabled()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "159": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.hasHaltingErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "160": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.hasErrors()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "161": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(modulesByName.hasRegExpGlobalReferences()){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "162": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.moduleGraph = new JSModuleGraph(this.modules);\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "163": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.modules = modules;\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "164": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.MISSING_ENTRY_ERROR){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "165": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(-1){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "166": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.initBasedOnOptions();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "167": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.rebuildInputsFromModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "168": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.initInputsByIdMap();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "169": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.disableThreads();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "170": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.compileInternal();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "171": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.parse();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "172": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.check();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "173": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.externExports();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "174": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.maybeSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "175": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.runSanityCheck();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "176": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.removeTryCatchFinally();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "177": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.endPass();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "178": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.resetUniqueNameId();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "179": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.hoistNoCompileFiles();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "180": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.repartitionInputs();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "181": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.processAMDAndCommonJSModules();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "182": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.initCompilerOptionsIfTesting();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "183": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.reset();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "184": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.optimize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "185": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.processDefines();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "186": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.normalize();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "187": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.recordFunctionInformation();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "188": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.reportCodeChange();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "189": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodulesByName.removeSyntheticVarsInput();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "190": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(this.modules){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "191": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nbreak;\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "192": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(true){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "193": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodules.add(modulesByInput.get(input));\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "194": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodules = Lists.newArrayList();\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "195": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nm.addDependency(root);\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "196": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nreport(JSError.make(MISSING_ENTRY_ERROR, require));\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "197": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(options.processCommonJSModules){\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n}\n    }\n  }",
          "198": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodule.addDependency(dependency);\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "199": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nThrowables.propagate(e);\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "200": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nmodules.add(0, root);\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "201": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(options.processCommonJSModules){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "202": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((dependency == null)){\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "203": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif((dependency == null)){\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n}\n    }\n  }",
          "204": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nbreak;\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "205": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(!true){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "206": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(0){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "207": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nreturn;\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "208": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\ncontinue;\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "209": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(\"null\"){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "210": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nif(null){        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "211": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nthis.moduleGraph = new JSModuleGraph(this.modules);\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "212": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n(JSModule module = ;\n:modules)      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "213": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\nList<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "214": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n(String require = ;\n:input.getRequires())      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }",
          "215": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n(CompilerInput input = ;\n:module.getInputs())      if (!true) {        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        JSModule root = new JSModule(\"root\");\n        for (JSModule m : modules) {\n          m.addDependency(root);\n        }\n        modules.add(0, root);\n        SortedDependencies<JSModule> sorter =\n          new SortedDependencies<JSModule>(modules);\n        modules = sorter.getDependenciesOf(modules, true);\n        this.modules = modules;\n\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }"
}