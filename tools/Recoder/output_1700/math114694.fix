{
          "0": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a - t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "1": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a >> t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "2": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "3": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a % t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "4": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a * t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "5": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a << t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "6": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a >>> t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "7": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (sintA / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "8": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a <= t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "9": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a & t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "10": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\nlong c = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "11": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a | t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "12": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\nint c = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "13": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = a;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "14": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble c = (a / sintA);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "15": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a / a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "16": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a * t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "17": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a - a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "18": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a * a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "19": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a / t) * a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "20": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "21": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a * a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "22": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a / t) / a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "23": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a % a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "24": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a / a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "25": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\nboolean c = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "26": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\nObject c = (a / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "27": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a + a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "28": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a * (a / t));\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "29": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a * a) * t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "30": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a / a) * t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "31": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a * a) / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "32": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a / a) / t);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "33": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\nreturn;\n        double c = a / t;        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "34": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a * a) * a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "35": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = ((a / a) * a);\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "36": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\ndouble  = (a * (a * a));\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb + est*est*xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }"
}