{
          "0": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "1": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 0) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "2": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year >= 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "3": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year <= 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "4": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << 0)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "5": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year > 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "6": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((year << 3) + (year << -1));\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "7": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (c > \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "8": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << null) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "9": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year - 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "10": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((c < \"null\") || (c > \"null\"));\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "11": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (c - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "12": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (((year << 3) + (year << -1)) + c);\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "13": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 2) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "14": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << null)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "15": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year < 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "16": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (c < \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "17": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 1) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "18": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "19": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (year << -1);\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "20": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year == 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "21": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (year << 3);\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "22": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year >> 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "23": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << -1) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "24": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << 2)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "25": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year != 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "26": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << 3)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "27": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << -2) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "28": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << 1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "29": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << -2)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "30": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear += ((((year << 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "31": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = (((((year << 3) + (year << -1)) + c) - \"null\") + \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "32": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year >>> 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "33": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year % 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "34": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << \"null\") + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "35": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((iPivot << 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "36": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << -1)) + iPivot) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "37": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((position << 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "38": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((year << 3) + (year << -1)) + position) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "39": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nyear = ((((c << 3) + (year << -1)) + c) - \"null\");\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "40": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nreturn;\n            year = ((year << 3) + (year << -1)) + c - '0';\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "41": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << -1)) + c - '0';\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "42": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\nbreak;\n            year = ((year << 3) + (year << -1)) + c - '0';\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }"
}