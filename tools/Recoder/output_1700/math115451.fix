{
          "0": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "1": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "2": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "3": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodB <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "4": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = prodA;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "5": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "6": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "7": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = prodB;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "8": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = 1;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "9": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA += prodA;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "10": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = 62;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "11": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA <<= 1;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "12": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n-prodA <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "13": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA |= (prodB >>> 62);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "14": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "15": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n-prodB <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "16": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA++ <<= 0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "17": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA + 62);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "18": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA - 62);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "19": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA + 1);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "20": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nthis;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "21": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodB + 62);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "22": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA - 1);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "23": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodB - 62);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "24": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA - 0);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "25": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA + 0);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "26": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA <<= 62;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "27": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nreturn;\n        prodA <<= 0;        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "28": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodB + prodB);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "29": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = (prodA + prodB);\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "30": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 0;        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "31": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA |= (prodB >>> 62);\n        prodA <<= 0;        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "32": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nbreak;\n        prodA <<= 0;        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "33": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = ((prodA == null))?prodA:0;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "34": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\nprodA = ((prodA == null))?prodA:prodA;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }"
}