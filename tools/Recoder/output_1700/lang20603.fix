{
          "0": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(true){            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "1": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(key){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "2": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(pattern){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "3": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern != null)){\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n}\n        }\n        return pattern;\n    }",
          "4": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(dateStyle){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "5": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nreturn null;        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "6": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(timeStyle){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "7": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(pattern.isEmpty()){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "8": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "9": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nreturn pattern;        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "10": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(formatter){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "11": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(!pattern){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "12": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(!key){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "13": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(!dateStyle){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "14": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nformatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "15": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern == null)){\nreturn null;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "16": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern == null)){\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n}\n        }\n        return pattern;\n    }",
          "17": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nformatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "18": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(timeStyle.intValue()){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "19": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nformatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "20": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern != null)){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "21": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nreturn;\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "22": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern == null)){\nreturn pattern;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "23": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(dateStyle.intValue()){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "24": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(!formatter){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "25": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(locale){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "26": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(!true){            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "27": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\npattern = (SimpleDateFormat)formatter;\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "28": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((key != null)){\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n}\n        }\n        return pattern;\n    }",
          "29": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((timeStyle == null)){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "30": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\npattern = previous;\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "31": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((dateStyle == null)){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "32": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && timeStyle)){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "33": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\npattern = pattern;\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "34": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && (\"null\" + locale))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "35": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern != null)){\nreturn null;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "36": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nbreak;\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "37": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nbreak;\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "38": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((previous != null)){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "39": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(false){            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "40": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && (pattern != null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "41": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && (pattern == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "42": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(\"null\"){            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "43": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && (timeStyle == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "44": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nreturn;\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "45": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((pattern && (timeStyle != null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "46": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(null){            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "47": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((timeStyle && (pattern != null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "48": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((dateStyle && (pattern != null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "49": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((dateStyle && (pattern == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "50": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif((timeStyle && (pattern == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "51": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nfinal MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "52": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nString pattern = cDateTimeInstanceCache.get(key);\n        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "53": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\ncontinue;\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "54": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern != null) && (pattern == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "55": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern != null) && (pattern != null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "56": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern == null) && (pattern == null))){\n            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "57": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern != null) && (pattern != null))){\nreturn null;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "58": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern == null) && (pattern != null))){\nreturn null;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }",
          "59": "    static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n\n        String pattern = cDateTimeInstanceCache.get(key);\nif(((pattern != null) && (pattern == null))){\nreturn null;}        if (false) {            try {\n                DateFormat formatter;\n                if (dateStyle == null) {\n                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    \n                }\n                else if (timeStyle == null) {\n                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    \n                }\n                else {\n                    formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                }\n                pattern = ((SimpleDateFormat)formatter).toPattern();\n                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                if (previous != null) {\n                    // even though it doesn't matter if another thread put the pattern\n                    // it's still good practice to return the String instance that is\n                    // actually in the ConcurrentMap\n                    pattern= previous;\n                }\n            } catch (final ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n            }\n        }\n        return pattern;\n    }"
}