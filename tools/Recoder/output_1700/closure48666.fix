{
          "0": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] > subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "1": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "2": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] < subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "3": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] <= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "4": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nreturn false;      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "5": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(subIdx + 1)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "6": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "7": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "8": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[superIdx] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "9": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges[(subIdx + 1)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "10": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[subIdx] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "11": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nsubIdx += 2;\n      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "12": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nsuperIdx += 2;\n      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "13": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 1)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "14": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superIdx + 0)){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "15": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nbreak;\n      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "16": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(superIdx + 0)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "17": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges[(superIdx + 0)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "18": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "19": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superIdx >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "20": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "21": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges)){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "22": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges[superIdx])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "23": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] == subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "24": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx + 0)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "25": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx >= 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "26": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subIdx + 1)){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "27": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges[subIdx])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "28": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges[superIdx] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "29": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subIdx >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "30": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRangesranges >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "31": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges[(superIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "32": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superIdx)){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "33": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] || subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "34": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges[subIdx] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "35": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] && subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "36": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((sub[(superIdx + 0)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "37": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= superRanges)){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "38": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((subRanges[(superIdx + 1)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "39": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superLen >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "40": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "41": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((sub[(subIdx + 1)] >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "42": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx + 2)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "43": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[superIdx])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "44": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx <= 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "45": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(superIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "46": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx > 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "47": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] != subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "48": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subRanges[(superIdx + 0)] + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "49": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[subIdx])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "50": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((sub >= subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "51": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subRanges + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "52": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subIdx)){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "53": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\ncontinue;\n      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "54": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx == 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "55": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx < 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "56": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "57": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] >= subRanges[(subIdx != 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "58": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((superRanges[(superIdx + 0)] & subRanges[(subIdx + 1)])){        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "59": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nreturn (subIdx == subLen);      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "60": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superIdx != null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "61": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "62": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges == null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "63": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges == subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "64": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\n      } else if (superRanges[superIdx + 0] >= subRanges[subIdx + 1]) {        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "65": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superIdx == null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "66": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superIdx == subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "67": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != superIdx) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "68": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superRanges != null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "69": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superIdx != subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "70": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges == superIdx) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "71": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges > subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "72": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superRanges != subRanges) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "73": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != subRanges[(superIdx + 0)]) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "74": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)])) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "75": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != null) && (subRanges == subRanges))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "76": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != null) && (superIdx == subRanges))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "77": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != null) && (subRanges == superIdx))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "78": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((subRanges != null) && (superIdx == superIdx))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "79": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif(((superIdx != null) && (subRanges == subRanges))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "80": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx == superIdx)) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "81": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx != superIdx)) && (superRanges[(superIdx + 0)] >= subRanges[(subIdx + 1)]))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "82": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx == superIdx)) && (subRanges == subRanges))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "83": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx == superIdx)) && (subRanges == superIdx))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "84": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx == superIdx)) && (superIdx == superIdx))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }",
          "85": "  public boolean containsAll(CharRanges sub) {\n    int[] superRanges = this.ranges;\n    int[] subRanges = sub.ranges;\n\n    int superIdx = 0, subIdx = 0;\n    int superLen = superRanges.length, subLen = subRanges.length;\n    while (subIdx < subLen) {\n      if (superIdx == superLen) {\n        return false;\n      }\n      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n        // Super range ends before subRange starts.\n        superIdx += 2;\n      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n        // Uncontained portion at start of sub range.\n        return false;\nif((((superIdx != null) && (superIdx == superIdx)) && (superIdx == subRanges))){\n        // A sub range is completely contained in the super range.\n        // We know this because of the above condition and we have already\n        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n        subIdx += 2;\n      } else {\n        // Uncontained portion at end of sub range.\n        return false;\n      }\n    }\n    return subIdx == subLen;\n  }"
}