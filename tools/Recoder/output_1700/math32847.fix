{
          "0": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((cycle++ % 2)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "1": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 0) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "2": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nindices.add(idx);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "3": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nitem = parent2Rep.get(idx);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "4": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "5": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nbreak;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "6": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) >= 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "7": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nchild1Rep.set(i, child2Rep.get(i));\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "8": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nidx = parent1Rep.indexOf(item);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "9": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nidx++;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "10": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nreturn new ChromosomePair(first.newFixedLengthChromosome(child1Rep), second.newFixedLengthChromosome(child2Rep));            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "11": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nidx = 0;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "12": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) <= 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "13": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nchild2Rep.set(i, tmp);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "14": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nidx = ((indices.get(0) + 1) % length);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "15": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((visitedIndices.size() < length)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "16": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ >= 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "17": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "18": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((indices.get(0) + 1)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "19": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ <= 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "20": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((i % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "21": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) < 0)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "22": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) > 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "23": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((cycle++ % 2)){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "24": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\n(int i = ;\n:indices)            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "25": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % -1) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "26": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) && (visitedIndices.size() < length))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "27": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nbreak;\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "28": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((visitedIndices.size() < length)){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "29": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\ncontinue;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "30": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((indices.get(0) + 1) % length)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "31": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((idx >= length)){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "32": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((indices.get(0) + 1)){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "33": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) || (visitedIndices.size() < length))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "34": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((idx >= length)){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "35": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nreturn 0;            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "36": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nreturn;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "37": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) && (cycle++ % 2))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "38": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((indices % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "39": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ > 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "40": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((idx % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "41": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((idx != indices.get(0))){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "42": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) || (cycle++ % 2))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "43": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\ni++;\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "44": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((visitedIndices.size() < length) && ((cycle++ % 2) < 0))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "45": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) == 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "46": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 1) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "47": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((item % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "48": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) && indices.get(0))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "49": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((tmp % 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "50": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((((cycle++ % 2) < 0) && (indices.get(0) + 1))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "51": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((visitedIndices.size() < length) || ((cycle++ % 2) < 0))){\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "52": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ == 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "53": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif((item != null)){\ncontinue;\n}\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "54": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ < 2) < 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "55": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) < 1)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "56": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "57": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) != 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "58": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nT tmp = child1Rep.get(i);\n            if (cycle++ % 2 < 0) {                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "59": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nif(((cycle++ % 2) - 0)){                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "60": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nitem = parent2Rep.get(idx);\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }",
          "61": "    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second)\n        throws DimensionMismatchException {\n\n        final int length = first.getLength();\n        if (length != second.getLength()) {\n            throw new DimensionMismatchException(second.getLength(), length);\n        }\n\n        // array representations of the parents\n        final List<T> parent1Rep = first.getRepresentation();\n        final List<T> parent2Rep = second.getRepresentation();\n        // and of the children: do a crossover copy to simplify the later processing\n        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n\n        // the set of all visited indices so far\n        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n        // the indices of the current cycle\n        final List<Integer> indices = new ArrayList<Integer>(length);\n\n        // determine the starting index\n        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n        int cycle = 1;\n\n        while (visitedIndices.size() < length) {\n            indices.add(idx);\n\n            T item = parent2Rep.get(idx);\n            idx = parent1Rep.indexOf(item);\n\n            while (idx != indices.get(0)) {\n                // add that index to the cycle indices\n                indices.add(idx);\n                // get the item in the second parent at that index\n                item = parent2Rep.get(idx);\n                // get the index of that item in the first parent\n                idx = parent1Rep.indexOf(item);\n            }\n\n            // for even cycles: swap the child elements on the indices found in this cycle\nindices.add(idx);\n                for (int i : indices) {\n                    T tmp = child1Rep.get(i);\n                    child1Rep.set(i, child2Rep.get(i));\n                    child2Rep.set(i, tmp);\n                }\n            }\n\n            visitedIndices.addAll(indices);\n            // find next starting index: last one + 1 until we find an unvisited index\n            idx = (indices.get(0) + 1) % length;\n            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n                idx++;\n                if (idx >= length) {\n                    idx = 0;\n                }\n            }\n            indices.clear();\n        }\n\n        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n                                  second.newFixedLengthChromosome(child2Rep));\n    }"
}