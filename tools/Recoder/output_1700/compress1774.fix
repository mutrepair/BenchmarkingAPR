{
          "0": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() != 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "1": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "2": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nfinish();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "3": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\ncloseEntry();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "4": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nclose();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "5": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nflush();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "6": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\ncloseArchiveEntry();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "7": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\ndeflate();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "8": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nwriteCentralDirectoryEnd();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "9": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\ndeflateUntilInputIsNeeded();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "10": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() >= 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "11": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nreturn;\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "12": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(entry.getMethod()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "13": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == STORED)){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "14": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nsuper.putNextEntry();\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "15": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() > 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "16": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((raf == null)){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "17": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((\"null\" + \"null\")){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "18": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(isSeekable()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "19": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() <= 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "20": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == DEFLATED)){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "21": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(!isSeekable()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "22": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(!entry.getMethod()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "23": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(ze){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "24": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(ze){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "25": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == STORED)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "26": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "27": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(entry.isEmpty()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "28": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((raf == null)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "29": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((method != 0)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "30": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == DEFLATED)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "31": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nentry.getMethod();\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "32": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((\"null\" + \"null\")){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "33": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() < 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "34": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(!entry.isEmpty()){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "35": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((ze != 0)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "36": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() == 1)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "37": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((method != 0)){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "38": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.putNextEntry() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "39": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getMethod() != 0)){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "40": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry != 0)){\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n}\n    }",
          "41": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nentry.setMethod(method);\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "42": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nentry.setTime(System.currentTimeMillis());\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "43": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nentries.add(entry);\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "44": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nentry.setCompressedSize(entry.getSize());\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "45": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getTime() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "46": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getSize() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "47": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getCrc() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "48": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nze = false;\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "49": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.currentTimeMillis() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "50": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\ndef.setLevel(level);\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "51": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif((entry.getName() == 0)){            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "52": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nhasCompressionLevelChanged = false;\n        if (entry.getMethod() == 0) { // not specified            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "53": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(((entry.getMethod() == 0) && (entry.getMethod() == 0))){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }",
          "54": "    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n        closeEntry();\n\n        entry = ze;\n        entries.add(entry);\n\nif(((method != 0) && (entry.getMethod() == 0))){\n            entry.setMethod(method);\n        }\n\n        if (entry.getTime() == -1) { // not specified\n            entry.setTime(System.currentTimeMillis());\n        }\n\n        // Size/CRC not required if RandomAccessFile is used\n        if (entry.getMethod() == STORED && raf == null) {\n            if (entry.getSize() == -1) {\n                throw new ZipException(\"uncompressed size is required for\"\n                                       + \" STORED method when not writing to a\"\n                                       + \" file\");\n            }\n            if (entry.getCrc() == -1) {\n                throw new ZipException(\"crc checksum is required for STORED\"\n                                       + \" method when not writing to a file\");\n            }\n            entry.setCompressedSize(entry.getSize());\n        }\n\n        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n            def.setLevel(level);\n            hasCompressionLevelChanged = false;\n        }\n        writeLocalFileHeader(entry);\n    }"
}