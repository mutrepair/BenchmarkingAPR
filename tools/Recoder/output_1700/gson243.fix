{
          "0": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, pair);\n  }",
          "1": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(1, pair);\n  }",
          "2": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(2, pair);\n  }",
          "3": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, index);\n  }",
          "4": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nreturn;\n    typeHierarchyList.add(-1, pair);  }",
          "5": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair);\n  }",
          "6": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nadd(-1, pair);\n  }",
          "7": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, -1);\n  }",
          "8": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nif((index >= 0)){\n}\n    typeHierarchyList.add(-1, pair);  }",
          "9": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\n  }",
          "10": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair.first);\n  }",
          "11": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, 0);\n  }",
          "12": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(index);\n  }",
          "13": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add();\n  }",
          "14": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nmakeUnmodifiable();\n}\n    typeHierarchyList.add(-1, pair);  }",
          "15": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, pair);\n  }",
          "16": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.remove(-1, pair);\n  }",
          "17": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(false, pair);\n  }",
          "18": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(null, pair);\n  }",
          "19": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, );\n  }",
          "20": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.log(-1, pair);\n  }",
          "21": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.remove(index);\n    typeHierarchyList.add(-1, pair);  }",
          "22": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nlogger.log(Level.WARNING, \"null\", pair.first);\n    typeHierarchyList.add(-1, pair);  }",
          "23": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, index);\n  }",
          "24": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, 1);\n  }",
          "25": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-2, pair);\n  }",
          "26": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, -index);\n  }",
          "27": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nadd(pair.first);\n  }",
          "28": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, );\n  }",
          "29": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nindex = typeHierarchyList.add(-1, pair);\n  }",
          "30": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, );\n  }",
          "31": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\npair.add(-1, pair);\n  }",
          "32": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nif(!modifiable){\n}\n    typeHierarchyList.add(-1, pair);  }",
          "33": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, );\n  }",
          "34": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nindex.add(-1, pair);\n  }",
          "35": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nindex = getIndexOfAnOverriddenHandler(pair.first);\n    typeHierarchyList.add(-1, pair);  }",
          "36": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(Level.WARNING, \"null\", pair.first);\n  }",
          "37": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(0, pair);\n  }",
          "38": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, 2);\n  }",
          "39": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nbreak;\n    typeHierarchyList.add(-1, pair);  }",
          "40": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, false);\n  }",
          "41": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nadd();\n  }",
          "42": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(true, pair);\n  }",
          "43": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.debug(-1, pair);\n  }",
          "44": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(\"null\", pair);\n  }",
          "45": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, ~index);\n  }",
          "46": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nLOG.add(-1, pair);\n  }",
          "47": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1);\n  }",
          "48": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, -1, -1);\n  }",
          "49": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nadd(index);\n  }",
          "50": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nregisterForTypeHierarchy(pair.first);\n  }",
          "51": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, true);\n  }",
          "52": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.registerForTypeHierarchy(-1, pair);\n  }",
          "53": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nif(((\"null\" + pair.first) + \"null\")){\n}\n    typeHierarchyList.add(-1, pair);  }",
          "54": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, ((((\"null\" + pair.first) + \"null\") + typeHierarchyList.get(index).first) + \"null\"));\n  }",
          "55": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\n    typeHierarchyList.add(-1, pair);  }",
          "56": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nif((\"null\" + pair.first)){\n}\n    typeHierarchyList.add(-1, pair);  }",
          "57": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, null);\n  }",
          "58": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, -1, 0);\n  }",
          "59": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nlogger.log(Level.WARNING, \"null\", pair.first);\n  }",
          "60": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.remove(index);\n  }",
          "61": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nif((pair != null)){\n}\n    typeHierarchyList.add(-1, pair);  }",
          "62": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.e(-1, pair);\n  }",
          "63": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, \"null\");\n  }",
          "64": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nMath.add(-1, pair);\n  }",
          "65": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nlogger.add(-1, pair);\n  }",
          "66": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.getIndexOfSpecificHandlerForTypeHierarchy(-1, pair);\n  }",
          "67": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, pair, 0);\n  }",
          "68": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\nindex = getIndexOfAnOverriddenHandler(pair.first);\n  }",
          "69": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, pair, -1);\n  }",
          "70": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(pair, -1, 1);\n  }",
          "71": "  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n    if (!modifiable) {\n      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n    }\n    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\n    if (index >= 0) {\n      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n      typeHierarchyList.remove(index);\n    }\n    index = getIndexOfAnOverriddenHandler(pair.first);\n    if (index >= 0) {\n      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n          + \" hides the previously registered type hierarchy handler for \"\n          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n    }\n    // We want stack behavior for adding to this list. A type adapter added subsequently should\n    // override a previously registered one.\ntypeHierarchyList.add(-1, first);\n  }"
}