{
          "0": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(true){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "1": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar != \"null\")){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "2": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nresolveTypes();\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "3": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nresolveStubDeclarations();\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "4": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nbuild();\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "5": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((superClassCtor == null)){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "6": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(sourceName){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "7": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((newVar.getInitialValue() == null)){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "8": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "9": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nreturn;\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "10": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(prototypeVar){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "11": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(OBJECT_TYPE){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "12": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(prototypeName){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "13": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar != null)){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "14": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(IFACE_INITIALIZER){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "15": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(prototypeSlot){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "16": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE))){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "17": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(newVar.getInitialValue()){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "18": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((superClassCtor == null)){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "19": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(prototypeVar.isEmpty()){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "20": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(CTOR_INITIALIZER){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "21": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(!n.isFromExterns()){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "22": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((newVar.getInitialValue() == null)){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "23": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar == \"null\")){\nreturn;\n}      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "24": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(superClassCtor){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "25": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar == \"null\")){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "26": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(!prototypeVar){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "27": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nscopeToDeclareIn.undeclare(prototypeVar);\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "28": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar != \"null\")){\nreturn;\n}      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "29": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(!sourceName){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "30": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(((superClassCtor == null) || superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE)))){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "31": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeName != \"null\")){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "32": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\ncompiler.report(JSError.make(sourceName, n, (fnType.isConstructor())?CTOR_INITIALIZER:IFACE_INITIALIZER, variableName));\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "33": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(n){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "34": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nscopeToDeclareIn.declare(prototypeName, n, prototypeSlot.getType(), input, ((superClassCtor == null) || superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE))));\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "35": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar != \"null\")){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "36": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(((superClassCtor == null) || superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE)))){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "37": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nprototypeSlot.setNode(n);\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "38": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(-true){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "39": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar == null)){\nreturn;\n}      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "40": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar == null)){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "41": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(((newVar.getInitialValue() == null) && !n.isFromExterns())){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "42": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar != null)){\nreturn;\n}      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "43": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nbreak;\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "44": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(fnType.isConstructor()){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "45": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(false){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "46": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nbreak;\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "47": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(1){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "48": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(((newVar.getInitialValue() == null) && !n.isFromExterns())){\n      if (false) {        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n}\n    }",
          "49": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nreturn;\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "50": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(null){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "51": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif(\"null\"){        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "52": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar && (sourceName != \"null\"))){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "53": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar && (scopeToDeclareIn != \"null\"))){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "54": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nif((prototypeVar && (fnType != \"null\"))){\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "55": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\ncompiler.report(JSError.make(sourceName, n, (fnType.isConstructor())?CTOR_INITIALIZER:IFACE_INITIALIZER, variableName));\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }",
          "56": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\nscopeToDeclareIn.undeclare(prototypeVar);\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }"
}